{"version":3,"file":"Event.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3BA;AACA;AAC4C;AACF;AAC1C;AACO,oCAAoC,mDAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAW,4BAA4B,kBAAkB;AACrF;AACA;AACA;AACA,gCAAgC,qDAAW;AAC3C,uCAAuC,qDAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC7CA;AACA;AACsC;AACc;AACV;AACP;AACa;AAChD,+BAA+B,oCAAoC;AAC5D,gCAAgC,mDAAU;AACjD,uCAAuC,2CAA2C,sBAAsB,kCAAkC;AAC1I;AACA;AACA,4CAA4C,4CAAQ;AACpD,mCAAmC,6DAAe;AAClD;AACA;AACA,mCAAmC,yDAAa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+CAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACbA;AACA;AACmC;AACnC;AACO;AACP;AACA;AACA,wCAAwC,4CAAQ;AAChD;AACA;AACA,uBAAuB,4DAAmC;AAC1D;AACA;AACA,6BAA6B,mBAAO,CAAC,yBAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAO,CAAC,2BAAc;AAC/C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mCAAmC,mBAAO,CAAC,+BAAkB;AAC7D;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,mBAAO,CAAC,iBAAI;AACvB;AACA;AACO;AACP,WAAW,mBAAO,CAAC,0BAAa;AAChC;AACA;;;;;;;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACO;AACP,sCAAsC,mCAAmC;AACzE;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,iBAAiB,aAAa,iBAAiB,WAAW;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sCAAsC,sCAAsC;AAC5E;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sCAAsC,iBAAiB;AACvD;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sCAAsC,mDAAmD;AACzF;AACA,eAAe,QAAQ;AACvB,eAAe,mBAAmB,eAAe,4CAA4C;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sCAAsC,gDAAgD;AACtF;AACA,eAAe,QAAQ;AACvB,eAAe,mBAAmB,eAAe,4CAA4C;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sCAAsC,qDAAqD;AAC3F;AACA,eAAe,QAAQ;AACvB,eAAe,mBAAmB,eAAe,4CAA4C;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sCAAsC,0DAA0D;AAChG;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sCAAsC,yCAAyC;AAC/E;AACA,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrIA;AACA;AAC+D;AACP;AACnB;AAC4B;AACW;AACrE,8BAA8B,mDAAU;AAC/C;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,YAAY,+DAAc;AAC1B;AACA;AACA;AACA;AACA,yCAAyC,qDAAa;AACtD;AACA;AACA,2BAA2B;AAC3B,YAAY,yEAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+CAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ;AACzC,4BAA4B,iDAAY;AACxC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAa;AAC7B;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ,sCAAsC,EAAE;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAS;AAC/B;AACA;AACA;AACA,mBAAmB,qDAAY;AAC/B;AACA;AACA;AACA,YAAY,4CAAQ;AACpB;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC1IA;AACA;AACwD;AAChB;AACxC;AACO;AACP;AACA;AACA,eAAe,iEAAiB;AAChC;AACA;AACA;AACA;AACA,YAAY,qDAAa;AACzB;AACA;AACA,sDAAsD,iEAAiB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,iEAAiB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iEAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClDA;AACA;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC9CA;AACA;AACgE;AACR;AACC;AAC2H;AAC/I;AAC4B;AACH;AACU;AACE;AAChB;AAC1D;AACA;AACO;AACP,iCAAiC;AACjC;AACA;AACA;AACA,QAAQ,uCAAG;AACX,uBAAuB,oDAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAQ,WAAW,UAAc;AAC7C,8BAA8B,sDAAK;AACnC,gCAAgC,+DAAc;AAC9C;AACA,aAAa,4CAAQ;AACrB;AACA;AACA,iBAAiB,4CAAQ;AACzB;AACA;AACA;AACA;AACA,aAAa,4CAAQ;AACrB;AACA;AACA,iBAAiB,4CAAQ;AACzB;AACA;AACA;AACA;AACA,+BAA+B,yEAAqB,2BAA2B,iEAAiB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,uDAAc;AACzD,QAAQ,uCAAG,sBAAsB,uDAAc;AAC/C,yBAAyB,8CAAQ,qDAAqD,uDAAc,iBAAiB;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA,sCAAsC,+CAAU;AAChD;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC,sCAAsC,+CAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ,uCAAuC,MAAM;AAClF;AACA;AACA;AACA,6BAA6B,8CAAQ,uCAAuC,MAAM;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ,wDAAwD,EAAE;AACnG;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,0DAAiB;AACjE;AACA,8DAA8D,0DAAiB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+CAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,0CAA0C,uEAAoB;AAC9D;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0DAAkB;AAChD;AACA;AACA,yBAAyB,8CAAQ,wCAAwC,aAAa;AACtF;AACA;AACA;AACA,2BAA2B,sCAAsC;AACjE;AACA;AACA,aAAa;AACb;AACA,mGAAmG,oBAAoB;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qEAAgC;AAC1E;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAS;AACtC;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC,sCAAsC,qEAAgC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,gBAAgB;AACnF;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8CAAQ,0CAA0C,mBAAmB,KAAK,GAAG;AAClH;AACA,iDAAiD,gEAA2B,IAAI,oBAAoB,UAAU,GAAG,GAAG,0DAAiB;AACrI;AACA;AACA,yCAAyC,8CAAQ;AACjD,kDAAkD,+CAAU;AAC5D;AACA;AACA;AACA;AACA;AACA,sCAAsC,oDAAe,0EAA0E,8BAA8B;AAC7J;AACA;AACA;AACA;AACA;AACA,iBAAiB,0DAAiB;AAClC;AACA;AACA;AACA,2BAA2B,mEAAkB,gJAAgJ;AAC7L,iBAAiB,0DAAiB;AAClC;AACA;AACA;AACA,2BAA2B,iFAAyB;AACpD,iBAAiB,0DAAiB;AAClC,2BAA2B,uEAAoB;AAC/C;AACA,sDAAsD,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAiB;AAC3C;AACA,6BAA6B,8CAAQ,+BAA+B,mBAAmB;AACvF,oDAAoD,mBAAmB;AACvE;AACA;AACA;AACA,4EAA4E,uDAAc;AAC1F;AACA,uCAAuC,0DAAiB;AACxD,uCAAuC,0DAAiB;AACxD,yCAAyC,8CAAQ,+BAA+B,0DAAiB,YAAY;AAC7G,mCAAmC,8DAAyB,KAAK,0DAAiB,YAAY;AAC9F;AACA;AACA,yCAAyC,8CAAQ,gCAAgC,0DAAiB,YAAY;AAC9G;AACA,oEAAoE,0DAAiB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8CAAQ,+BAA+B,0DAAiB,YAAY,+DAA+D,uDAAc,0BAA0B;AAChN,yCAAyC,0DAAiB,YAAY,qBAAqB,uDAAc,0BAA0B;AACnI;AACA;AACA;AACA,iCAAiC,8CAAQ,+BAA+B,0DAAiB,YAAY;AACrG,2BAA2B,2DAAsB,KAAK,0DAAiB,YAAY;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8CAAQ,yCAAyC,MAAM,0BAA0B,sBAAsB;AAChI;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ,iDAAiD,MAAM;AAC5F;AACA;AACA;AACA,6BAA6B,8CAAQ,mDAAmD,MAAM;AAC9F,6DAA6D,MAAM;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ,+CAA+C,MAAM;AAC1F;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA,iCAAiC,8CAAQ,kDAAkD,EAAE;AAC7F,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ,kCAAkC,MAAM,iBAAiB,EAAE;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4CAAQ;AACrB,+CAA+C,IAAI;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8CAAQ,8BAA8B,IAAI,QAAQ,UAAU;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,uBAAuB,kBAAkB,cAAc;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACvjBA;AACA;AACwD;AAClB;AACO;AACR;AACD;AACoB;AACR;AAChD;AACA;AACA;AACA,wCAAwC,qBAAqB;AACtD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA,QAAQ,uCAAG;AACX,QAAQ,uCAAG;AACX,QAAQ,uCAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iEAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,MAAM,sDAAW,OAAO;AACxF;AACA,oCAAoC,qBAAqB;AACzD;AACA;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8CAAQ;AACjC;AACA;AACA,gBAAgB,4CAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA,6BAA6B,8CAAQ,wEAAwE,EAAE;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA,6BAA6B,8CAAQ,oCAAoC,oBAAoB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yDAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ,4CAA4C,EAAE;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ,sCAAsC,MAAM;AACjF;AACA;AACA;AACA,6BAA6B,8CAAQ,uCAAuC,MAAM;AAClF;AACA;AACA;AACA;AACA,yBAAyB,8CAAQ;AACjC;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+CAAU;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6CAAO;AACnC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,sDAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,sDAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,qBAAqB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sDAAW;AACpC;AACA;AACA;AACA,yBAAyB,sDAAW;AACpC,yBAAyB,sDAAW;AACpC;AACA;AACA,iDAAiD,sDAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,8CAAQ,wCAAwC,sDAAc,IAAI;AACnH;AACA;AACA;AACA;AACA,yBAAyB,sDAAW;AACpC;AACA;AACA,yBAAyB,sDAAW;AACpC,yCAAyC,8CAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sDAAW;AACpC;AACA;AACA;AACA;AACA,yBAAyB,sDAAW;AACpC;AACA;AACA;AACA;AACA;AACA,yCAAyC,8CAAQ,mCAAmC,aAAa;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ,6CAA6C,WAAW;AAC7F;AACA;AACA,iCAAiC,8CAAQ,kCAAkC,WAAW,8BAA8B,+BAA+B;AACnJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8CAAQ,0CAA0C,WAAW;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ,sCAAsC,WAAW,iBAAiB,EAAE;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG,UAAU;AAC/G;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ,kCAAkC,WAAW,8BAA8B,+BAA+B;AACnJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ,6BAA6B,WAAW;AACjF;AACA;AACA;AACA;AACA,yBAAyB,8CAAQ,0CAA0C,MAAM,0BAA0B,sBAAsB;AACjI;AACA,gFAAgF,+CAAU;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ,kDAAkD,MAAM,iBAAiB,EAAE;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ,2DAA2D,MAAM;AACtG;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ,yDAAyD,MAAM,iBAAiB,EAAE;AAC3H;AACA;AACA;AACA,iCAAiC,8CAAQ;AACzC;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ,0CAA0C,2BAA2B,gBAAgB,gBAAgB;AAC1I;AACA;AACA,aAAa;AACb;AACA;AACA,iCAAiC,8CAAQ;AACzC;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ;AACzC;AACA;AACA;AACA;AACA;AACA,yCAAyC,8CAAQ,+DAA+D,+BAA+B,eAAe,EAAE;AAChK;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ,4DAA4D,EAAE;AACvG;AACA,qCAAqC,8CAAQ,oCAAoC,sBAAsB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8CAAQ,6DAA6D,iCAAiC,SAAS,2BAA2B;AACnK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,6BAA6B,8CAAQ,qDAAqD,mBAAmB,IAAI,oBAAoB,iBAAiB,EAAE;AACxJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ,gDAAgD,MAAM,iBAAiB,sDAAc,IAAI;AAClI;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sDAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sDAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAW;AACjC;AACA;AACA;AACA;AACA;AACA,kBAAkB,sDAAW;AAC7B;AACA;AACA;AACA,iBAAiB,MAAM,sDAAW;AAClC;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACx6BA;AACA;AACkE;AAChB;AACF;AACX;AACe;AACb;AACM;AAC7C;AACA,WAAW,8CAAQ;AACnB,WAAW,8CAAQ;AACnB,UAAU,8CAAQ;AAClB,iBAAiB,8CAAQ;AACzB,UAAU,8CAAQ;AAClB,aAAa,8CAAQ;AACrB,WAAW,8CAAQ;AACnB,cAAc,8CAAQ;AACtB,UAAU,8CAAQ;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,KAAK;AACnD;AACA;AACA,+BAA+B,wCAAwC;AAChE;AACP;AACA,QAAQ,uCAAG;AACX;AACA;AACA;AACA;AACA;AACA,8BAA8B,iDAAa;AAC3C;AACA;AACA,8BAA8B,iDAAa;AAC3C;AACA;AACA;AACA;AACA,QAAQ,uCAAG;AACX,QAAQ,uCAAG;AACX;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wCAAwC;AAChE;AACA,eAAe,cAAc,cAAc,uCAAuC;AAClF;AACA;AACA,QAAQ,uCAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2EAAsB;AAC7D;AACA;AACA,uCAAuC,2EAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAoE,SAAS,uCAAuC;AACxI;AACA,qBAAqB,+CAA+C;AACpE;AACA;AACA,QAAQ,uCAAG;AACX;AACA;AACA;AACA,oBAAoB,wEAAwE,SAAS,uCAAuC;AAC5I;AACA,qBAAqB,+CAA+C;AACpE;AACA;AACA,QAAQ,uCAAG;AACX;AACA;AACA;AACA;AACA;AACA,qBAAqB,+CAA+C;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wCAAwC;AAC3D;AACA,iBAAiB,eAAe,gBAAgB,uCAAuC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2DAAc;AAC7C,eAAe,yDAAa,mCAAmC,gDAAU,gCAAgC,6DAAe;AACxH;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/IA;AACA;AACA;AACO;AACP;AACA,2EAA2E,4CAA4C;AACvH;AACA,0EAA0E,4CAA4C;AACtH;AACA,0EAA0E,4CAA4C;AACtH;AACA,iFAAiF,kDAAkD;AACnI;AACA,iFAAiF,kDAAkD;AACnI;AACA,oEAAoE,sCAAsC;AAC1G;AACA,qEAAqE,uCAAuC;AAC5G;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AAC6C;AACR;AACS;AACP;AACiB;AACxD;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAc;AAC5C;AACA,6BAA6B,qCAAqC;AAClE;AACA,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gDAAU;AAC/B;AACA;AACA,yBAAyB,iEAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sDAAW;AAChC;AACA;AACA,qBAAqB,sDAAW;AAChC;AACA;AACA,qBAAqB,sDAAW;AAChC;AACA;AACA,qBAAqB,sDAAW;AAChC;AACA;AACA,qBAAqB,sDAAW;AAChC;AACA;AACA,qBAAqB,sDAAW;AAChC;AACA;AACA,qBAAqB,sDAAW;AAChC;AACA;AACA;AACA;AACA,+BAA+B,8CAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qCAAqC;AACnE;AACA,eAAe,YAAY;AAC3B,iBAAiB,QAAQ;AACzB;AACA;AACA,eAAe,iEAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtHA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oCAAoC;AACvE;AACA;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACoD;AACD;AACd;AACS;AACgC;AAC9E;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6DAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uCAAG;AACX,QAAQ,uCAAG;AACX,QAAQ,uCAAG,sBAAsB,uDAAc;AAC/C;AACA,yBAAyB,8CAAQ;AACjC;AACA,+BAA+B,uDAAc;AAC7C;AACA;AACA;AACA,8BAA8B,0DAAkB;AAChD,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uDAAc;AAC7C;AACA;AACA;AACA;AACA,2BAA2B,IAAI,KAAK,WAAW;AAC/C,yBAAyB,8CAAQ,4CAA4C,QAAQ;AACrF;AACA;AACA,6BAA6B,8CAAQ,6DAA6D,oBAAoB;AACtH;AACA,mCAAmC,8CAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,IAAI,KAAK,WAAW;AAC3D,qCAAqC,8CAAQ,4CAA4C,QAAQ;AACjG;AACA;AACA,yCAAyC,8CAAQ;AACjD;AACA;AACA;AACA,yCAAyC,8CAAQ,6DAA6D,oBAAoB;AAClI;AACA,+CAA+C,8CAAS;AACxD;AACA;AACA;AACA;AACA;AACA,6CAA6C,8CAAQ,kDAAkD,qDAAa,oDAAoD;AACxK;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,8CAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,8CAAQ,gEAAgE,UAAU;AAC3H;AACA;AACA,yCAAyC,iDAAY;AACrD;AACA,6CAA6C,8CAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAW;AAC1B;AACA;AACA,yBAAyB,8CAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ,6DAA6D,UAAU;AAC5G;AACA,kCAAkC,0DAAkB;AACpD;AACA;AACA,2BAA2B,sCAAsC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8CAAS;AAC9C;AACA,yCAAyC,8CAAQ;AACjD;AACA;AACA,yCAAyC,8CAAQ,mEAAmE,MAAM;AAC1H;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ;AACzC;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtLA;AACA;AAC6C;AACL;AACxC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA,oBAAoB,qDAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sDAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,MAAM,sDAAW,uBAAuB;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sDAAW;AAC5B,iBAAiB,sDAAW;AAC5B,iBAAiB,sDAAW;AAC5B,iBAAiB,sDAAW;AAC5B,iBAAiB,sDAAW;AAC5B;AACA,iBAAiB,sDAAW;AAC5B,iBAAiB,sDAAW;AAC5B,iBAAiB,sDAAW;AAC5B,iBAAiB,sDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,MAAM,sDAAW,kDAAkD;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACjMA;AACA;AACqC;AACS;AAC0C;AACxF;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uCAAG;AACX,QAAQ,uCAAG;AACX,QAAQ,uCAAG,sBAAsB,uDAAc;AAC/C,yBAAyB,8CAAQ;AACjC;AACA;AACA;AACA,wEAAwE,sCAAsC;AAC9G;AACA;AACA;AACA,mCAAmC,uDAAc;AACjD;AACA;AACA;AACA;AACA,gBAAgB,4CAAQ,cAAc,4CAAQ;AAC9C,mEAAmE,gDAAgD;AACnH;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,0DAAkB;AACxD;AACA,mEAAmE,2DAA2D,wCAAwC;AACtK;AACA;AACA;AACA;AACA;AACA,6CAA6C,8CAAQ,0CAA0C,qDAAa,0CAA0C;AACtJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8CAAQ,kCAAkC,UAAU;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtGA;AACA;AAC8C;AAC9C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAmB;AACtC;AACA;AACA;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,OAAO,EAAE,kCAAkC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACqC;AACE;AACvC;AACA;AACO;AACP;AACO;AACP;AACA;AACA,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA,uCAAuC,MAAM,SAAS,IAAI;AAC1D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,0CAA0C,gBAAgB;AAC1D;AACA,qCAAqC,wBAAwB;AAC7D;AACA;AACA;AACA,0CAA0C,YAAY;AACtD;AACA,qCAAqC,KAAK;AAC1C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI,EAAE,kBAAkB;AAC5C,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,8CAAQ,YAAY,eAAe,2BAA2B,kDAAkD;AAC/H;AACA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA,KAAK;AACL,eAAe,8CAAQ,YAAY,eAAe,gDAAgD,oBAAoB;AACtH;AACA;AACO;AACP;AACA,iCAAiC,8CAAQ;AACzC;AACA;AACA,eAAe,gDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB,IAAI,8CAAQ,WAAW,IAAI,QAAQ;AACxF;AACA,qBAAqB,8CAAQ;AAC7B,qBAAqB,8CAAQ;AAC7B;AACA;AACA,qBAAqB,8CAAQ;AAC7B;AACA;AACA,qBAAqB,8CAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,wDAAwD,oBAAoB,WAAW;AACvF;AACA;AACA,oBAAoB,iBAAiB,GAAG,iBAAiB;AACzD,sBAAsB,UAAU;AAChC;AACA,wBAAwB,KAAK;AAC7B;AACA;AACA,kCAAkC;AAClC;AACA,oBAAoB,QAAQ;AAC5B;AACA,wBAAwB,EAAE,eAAe;AACzC;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,EAAE;AAChB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAM;AACrB,eAAe,qBAAM;AACrB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvPA;AACA;AAC4C;AACP;AACS;AAC6B;AAC3E;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uCAAG;AACX,QAAQ,uCAAG;AACX,QAAQ,uCAAG,sBAAsB,uDAAc;AAC/C,yBAAyB,8CAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAQ,WAAW,4CAAQ;AAC3C;AACA,sCAAsC,0DAAkB;AACxD;AACA;AACA,4BAA4B,qDAAW,4BAA4B,MAAM;AACzE;AACA;AACA,4BAA4B,qDAAW;AACvC;AACA;AACA;AACA,+BAA+B,8BAA8B;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA,gFAAgF,0BAA0B;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uDAAc;AACjD;AACA;AACA;AACA,iCAAiC,8CAAQ,wCAAwC,IAAI;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ,wCAAwC,MAAM;AACvF;AACA;AACA,iCAAiC,8CAAQ,iDAAiD,qDAAa,wCAAwC;AAC/I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,6BAA6B,8CAAQ,gDAAgD,qDAAa,gCAAgC;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8CAAQ;AACjC;AACA;AACA,6EAA6E,YAAY,GAAG,kCAAkC;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC1JA;AACA;AAC+D;AACP;AACnB;AACG;AACjC,4BAA4B,mDAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+CAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qDAAa;AACjC;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAY;AAC5C;AACA;AACA,+BAA+B,8CAAS;AACxC;AACA;AACA;AACA,iCAAiC,8CAAQ,sCAAsC,WAAW,IAAI,eAAe;AAC7G,2BAA2B,8CAAS;AACpC;AACA;AACA,iCAAiC,8CAAQ;AACzC,2BAA2B,iDAAY;AACvC;AACA;AACA,SAAS;AACT;AACA;A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","sources":["webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/AbortController.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/AccessTokenHttpClient.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/DefaultHttpClient.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/DefaultReconnectPolicy.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/DynamicImports.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/Errors.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/FetchHttpClient.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/HandshakeProtocol.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/HeaderNames.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/HttpClient.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/HttpConnection.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/HubConnection.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/HubConnectionBuilder.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/IHubProtocol.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/ILogger.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/ITransport.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/JsonHubProtocol.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/Loggers.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/LongPollingTransport.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/MessageBuffer.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/ServerSentEventsTransport.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/Subject.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/TextMessageFormat.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/Utils.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/WebSocketTransport.js","webpack://offlineMeeting/./node_modules/@microsoft/signalr/dist/esm/XhrHttpClient.js","webpack://offlineMeeting/./wwwroot/ts/Event/CanvasVideo.ts","webpack://offlineMeeting/./wwwroot/ts/Event/EventControlModal.ts","webpack://offlineMeeting/./wwwroot/ts/Event/GetCamera.ts","webpack://offlineMeeting/./wwwroot/ts/Event/GetCameraInformation.ts","webpack://offlineMeeting/./wwwroot/ts/Event/RegisterVideo.ts","webpack://offlineMeeting/./wwwroot/ts/Event/StartGame.ts","webpack://offlineMeeting/./wwwroot/ts/Event/StartVideoMedia.ts","webpack://offlineMeeting/./wwwroot/ts/Event/VideoControll.ts","webpack://offlineMeeting/./wwwroot/ts/Event/VideoTestControll.ts","webpack://offlineMeeting/./wwwroot/ts/GameData/EndHand.ts","webpack://offlineMeeting/./wwwroot/ts/GameData/RecordMedia.ts","webpack://offlineMeeting/./wwwroot/ts/GameData/RecordVideo.ts","webpack://offlineMeeting/./wwwroot/ts/GameData/RegisterEndGame.ts","webpack://offlineMeeting/./wwwroot/ts/GameData/RegisterEndHand.ts","webpack://offlineMeeting/./wwwroot/ts/GameData/SelectEndHand.ts","webpack://offlineMeeting/./wwwroot/ts/GameData/SetAvoidSelectDuplication.ts","webpack://offlineMeeting/./wwwroot/ts/GameData/ShowPoint.ts","webpack://offlineMeeting/./wwwroot/ts/share/ControlModal.ts","webpack://offlineMeeting/./wwwroot/ts/share/FetchApi.ts","webpack://offlineMeeting/./wwwroot/ts/share/GetNewResolutions.ts","webpack://offlineMeeting/./wwwroot/ts/share/SetEventListner.ts","webpack://offlineMeeting/./wwwroot/ts/share/SetOutSameClassSelect.ts","webpack://offlineMeeting/./wwwroot/ts/share/SignalR.ts","webpack://offlineMeeting/ignored|C:\\webPrivate\\offlineMeeting\\offlineMeeting\\node_modules\\@microsoft\\signalr\\dist\\esm|abort-controller","webpack://offlineMeeting/ignored|C:\\webPrivate\\offlineMeeting\\offlineMeeting\\node_modules\\@microsoft\\signalr\\dist\\esm|eventsource","webpack://offlineMeeting/ignored|C:\\webPrivate\\offlineMeeting\\offlineMeeting\\node_modules\\@microsoft\\signalr\\dist\\esm|fetch-cookie","webpack://offlineMeeting/ignored|C:\\webPrivate\\offlineMeeting\\offlineMeeting\\node_modules\\@microsoft\\signalr\\dist\\esm|node-fetch","webpack://offlineMeeting/ignored|C:\\webPrivate\\offlineMeeting\\offlineMeeting\\node_modules\\@microsoft\\signalr\\dist\\esm|tough-cookie","webpack://offlineMeeting/ignored|C:\\webPrivate\\offlineMeeting\\offlineMeeting\\node_modules\\@microsoft\\signalr\\dist\\esm|ws","webpack://offlineMeeting/webpack/bootstrap","webpack://offlineMeeting/webpack/runtime/define property getters","webpack://offlineMeeting/webpack/runtime/global","webpack://offlineMeeting/webpack/runtime/hasOwnProperty shorthand","webpack://offlineMeeting/webpack/runtime/make namespace object","webpack://offlineMeeting/./wwwroot/ts/Event/Index.ts"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n// Rough polyfill of https://developer.mozilla.org/en-US/docs/Web/API/AbortController\r\n// We don't actually ever use the API being polyfilled, we always use the polyfill because\r\n// it's a very new API right now.\r\n// Not exported from index.\r\n/** @private */\r\nexport class AbortController {\r\n    constructor() {\r\n        this._isAborted = false;\r\n        this.onabort = null;\r\n    }\r\n    abort() {\r\n        if (!this._isAborted) {\r\n            this._isAborted = true;\r\n            if (this.onabort) {\r\n                this.onabort();\r\n            }\r\n        }\r\n    }\r\n    get signal() {\r\n        return this;\r\n    }\r\n    get aborted() {\r\n        return this._isAborted;\r\n    }\r\n}\r\n//# sourceMappingURL=AbortController.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { HttpClient } from \"./HttpClient\";\r\n/** @private */\r\nexport class AccessTokenHttpClient extends HttpClient {\r\n    constructor(innerClient, accessTokenFactory) {\r\n        super();\r\n        this._innerClient = innerClient;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n    }\r\n    async send(request) {\r\n        let allowRetry = true;\r\n        if (this._accessTokenFactory && (!this._accessToken || (request.url && request.url.indexOf(\"/negotiate?\") > 0))) {\r\n            // don't retry if the request is a negotiate or if we just got a potentially new token from the access token factory\r\n            allowRetry = false;\r\n            this._accessToken = await this._accessTokenFactory();\r\n        }\r\n        this._setAuthorizationHeader(request);\r\n        const response = await this._innerClient.send(request);\r\n        if (allowRetry && response.statusCode === 401 && this._accessTokenFactory) {\r\n            this._accessToken = await this._accessTokenFactory();\r\n            this._setAuthorizationHeader(request);\r\n            return await this._innerClient.send(request);\r\n        }\r\n        return response;\r\n    }\r\n    _setAuthorizationHeader(request) {\r\n        if (!request.headers) {\r\n            request.headers = {};\r\n        }\r\n        if (this._accessToken) {\r\n            request.headers[HeaderNames.Authorization] = `Bearer ${this._accessToken}`;\r\n        }\r\n        // don't remove the header if there isn't an access token factory, the user manually added the header in this case\r\n        else if (this._accessTokenFactory) {\r\n            if (request.headers[HeaderNames.Authorization]) {\r\n                delete request.headers[HeaderNames.Authorization];\r\n            }\r\n        }\r\n    }\r\n    getCookieString(url) {\r\n        return this._innerClient.getCookieString(url);\r\n    }\r\n}\r\n//# sourceMappingURL=AccessTokenHttpClient.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { AbortError } from \"./Errors\";\r\nimport { FetchHttpClient } from \"./FetchHttpClient\";\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { Platform } from \"./Utils\";\r\nimport { XhrHttpClient } from \"./XhrHttpClient\";\r\n/** Default implementation of {@link @microsoft/signalr.HttpClient}. */\r\nexport class DefaultHttpClient extends HttpClient {\r\n    /** Creates a new instance of the {@link @microsoft/signalr.DefaultHttpClient}, using the provided {@link @microsoft/signalr.ILogger} to log messages. */\r\n    constructor(logger) {\r\n        super();\r\n        if (typeof fetch !== \"undefined\" || Platform.isNode) {\r\n            this._httpClient = new FetchHttpClient(logger);\r\n        }\r\n        else if (typeof XMLHttpRequest !== \"undefined\") {\r\n            this._httpClient = new XhrHttpClient(logger);\r\n        }\r\n        else {\r\n            throw new Error(\"No usable HttpClient found.\");\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    send(request) {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new AbortError());\r\n        }\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n        return this._httpClient.send(request);\r\n    }\r\n    getCookieString(url) {\r\n        return this._httpClient.getCookieString(url);\r\n    }\r\n}\r\n//# sourceMappingURL=DefaultHttpClient.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n// 0, 2, 10, 30 second delays before reconnect attempts.\r\nconst DEFAULT_RETRY_DELAYS_IN_MILLISECONDS = [0, 2000, 10000, 30000, null];\r\n/** @private */\r\nexport class DefaultReconnectPolicy {\r\n    constructor(retryDelays) {\r\n        this._retryDelays = retryDelays !== undefined ? [...retryDelays, null] : DEFAULT_RETRY_DELAYS_IN_MILLISECONDS;\r\n    }\r\n    nextRetryDelayInMilliseconds(retryContext) {\r\n        return this._retryDelays[retryContext.previousRetryCount];\r\n    }\r\n}\r\n//# sourceMappingURL=DefaultReconnectPolicy.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { Platform } from \"./Utils\";\r\n/** @private */\r\nexport function configureFetch(obj) {\r\n    // Node added a fetch implementation to the global scope starting in v18.\r\n    // We need to add a cookie jar in node to be able to share cookies with WebSocket\r\n    if (typeof fetch === \"undefined\" || Platform.isNode) {\r\n        // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\r\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n        obj._jar = new (require(\"tough-cookie\")).CookieJar();\r\n        if (typeof fetch === \"undefined\") {\r\n            // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n            obj._fetchType = require(\"node-fetch\");\r\n        }\r\n        else {\r\n            // Use fetch from Node if available\r\n            obj._fetchType = fetch;\r\n        }\r\n        // node-fetch doesn't have a nice API for getting and setting cookies\r\n        // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\r\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n        obj._fetchType = require(\"fetch-cookie\")(obj._fetchType, obj._jar);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n/** @private */\r\nexport function configureAbortController(obj) {\r\n    if (typeof AbortController === \"undefined\") {\r\n        // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\r\n        obj._abortControllerType = require(\"abort-controller\");\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n/** @private */\r\nexport function getWS() {\r\n    return require(\"ws\");\r\n}\r\n/** @private */\r\nexport function getEventSource() {\r\n    return require(\"eventsource\");\r\n}\r\n//# sourceMappingURL=DynamicImports.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n/** Error thrown when an HTTP request fails. */\r\nexport class HttpError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     * @param {number} statusCode The HTTP status code represented by this error.\r\n     */\r\n    constructor(errorMessage, statusCode) {\r\n        const trueProto = new.target.prototype;\r\n        super(`${errorMessage}: Status code '${statusCode}'`);\r\n        this.statusCode = statusCode;\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when a timeout elapses. */\r\nexport class TimeoutError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.TimeoutError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     */\r\n    constructor(errorMessage = \"A timeout occurred.\") {\r\n        const trueProto = new.target.prototype;\r\n        super(errorMessage);\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when an action is aborted. */\r\nexport class AbortError extends Error {\r\n    /** Constructs a new instance of {@link AbortError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     */\r\n    constructor(errorMessage = \"An abort occurred.\") {\r\n        const trueProto = new.target.prototype;\r\n        super(errorMessage);\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when the selected transport is unsupported by the browser. */\r\n/** @private */\r\nexport class UnsupportedTransportError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.UnsupportedTransportError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\r\n     */\r\n    constructor(message, transport) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.transport = transport;\r\n        this.errorType = 'UnsupportedTransportError';\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when the selected transport is disabled by the browser. */\r\n/** @private */\r\nexport class DisabledTransportError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.DisabledTransportError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\r\n     */\r\n    constructor(message, transport) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.transport = transport;\r\n        this.errorType = 'DisabledTransportError';\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when the selected transport cannot be started. */\r\n/** @private */\r\nexport class FailedToStartTransportError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.FailedToStartTransportError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\r\n     */\r\n    constructor(message, transport) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.transport = transport;\r\n        this.errorType = 'FailedToStartTransportError';\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when the negotiation with the server failed to complete. */\r\n/** @private */\r\nexport class FailedToNegotiateWithServerError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.FailedToNegotiateWithServerError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     */\r\n    constructor(message) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.errorType = 'FailedToNegotiateWithServerError';\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when multiple errors have occurred. */\r\n/** @private */\r\nexport class AggregateErrors extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.AggregateErrors}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {Error[]} innerErrors The collection of errors this error is aggregating.\r\n     */\r\n    constructor(message, innerErrors) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.innerErrors = innerErrors;\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n//# sourceMappingURL=Errors.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpResponse } from \"./HttpClient\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { Platform, getGlobalThis, isArrayBuffer } from \"./Utils\";\r\nimport { configureAbortController, configureFetch } from \"./DynamicImports\";\r\nexport class FetchHttpClient extends HttpClient {\r\n    constructor(logger) {\r\n        super();\r\n        this._logger = logger;\r\n        // This is how you do \"reference\" arguments\r\n        const fetchObj = { _fetchType: undefined, _jar: undefined };\r\n        if (configureFetch(fetchObj)) {\r\n            this._fetchType = fetchObj._fetchType;\r\n            this._jar = fetchObj._jar;\r\n        }\r\n        else {\r\n            this._fetchType = fetch.bind(getGlobalThis());\r\n        }\r\n        this._abortControllerType = AbortController;\r\n        const abortObj = { _abortControllerType: this._abortControllerType };\r\n        if (configureAbortController(abortObj)) {\r\n            this._abortControllerType = abortObj._abortControllerType;\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    async send(request) {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            throw new AbortError();\r\n        }\r\n        if (!request.method) {\r\n            throw new Error(\"No method defined.\");\r\n        }\r\n        if (!request.url) {\r\n            throw new Error(\"No url defined.\");\r\n        }\r\n        const abortController = new this._abortControllerType();\r\n        let error;\r\n        // Hook our abortSignal into the abort controller\r\n        if (request.abortSignal) {\r\n            request.abortSignal.onabort = () => {\r\n                abortController.abort();\r\n                error = new AbortError();\r\n            };\r\n        }\r\n        // If a timeout has been passed in, setup a timeout to call abort\r\n        // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\r\n        let timeoutId = null;\r\n        if (request.timeout) {\r\n            const msTimeout = request.timeout;\r\n            timeoutId = setTimeout(() => {\r\n                abortController.abort();\r\n                this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                error = new TimeoutError();\r\n            }, msTimeout);\r\n        }\r\n        if (request.content === \"\") {\r\n            request.content = undefined;\r\n        }\r\n        if (request.content) {\r\n            // Explicitly setting the Content-Type header for React Native on Android platform.\r\n            request.headers = request.headers || {};\r\n            if (isArrayBuffer(request.content)) {\r\n                request.headers[\"Content-Type\"] = \"application/octet-stream\";\r\n            }\r\n            else {\r\n                request.headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\r\n            }\r\n        }\r\n        let response;\r\n        try {\r\n            response = await this._fetchType(request.url, {\r\n                body: request.content,\r\n                cache: \"no-cache\",\r\n                credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\r\n                headers: {\r\n                    \"X-Requested-With\": \"XMLHttpRequest\",\r\n                    ...request.headers,\r\n                },\r\n                method: request.method,\r\n                mode: \"cors\",\r\n                redirect: \"follow\",\r\n                signal: abortController.signal,\r\n            });\r\n        }\r\n        catch (e) {\r\n            if (error) {\r\n                throw error;\r\n            }\r\n            this._logger.log(LogLevel.Warning, `Error from HTTP request. ${e}.`);\r\n            throw e;\r\n        }\r\n        finally {\r\n            if (timeoutId) {\r\n                clearTimeout(timeoutId);\r\n            }\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = null;\r\n            }\r\n        }\r\n        if (!response.ok) {\r\n            const errorMessage = await deserializeContent(response, \"text\");\r\n            throw new HttpError(errorMessage || response.statusText, response.status);\r\n        }\r\n        const content = deserializeContent(response, request.responseType);\r\n        const payload = await content;\r\n        return new HttpResponse(response.status, response.statusText, payload);\r\n    }\r\n    getCookieString(url) {\r\n        let cookies = \"\";\r\n        if (Platform.isNode && this._jar) {\r\n            // @ts-ignore: unused variable\r\n            this._jar.getCookies(url, (e, c) => cookies = c.join(\"; \"));\r\n        }\r\n        return cookies;\r\n    }\r\n}\r\nfunction deserializeContent(response, responseType) {\r\n    let content;\r\n    switch (responseType) {\r\n        case \"arraybuffer\":\r\n            content = response.arrayBuffer();\r\n            break;\r\n        case \"text\":\r\n            content = response.text();\r\n            break;\r\n        case \"blob\":\r\n        case \"document\":\r\n        case \"json\":\r\n            throw new Error(`${responseType} is not supported.`);\r\n        default:\r\n            content = response.text();\r\n            break;\r\n    }\r\n    return content;\r\n}\r\n//# sourceMappingURL=FetchHttpClient.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { TextMessageFormat } from \"./TextMessageFormat\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n/** @private */\r\nexport class HandshakeProtocol {\r\n    // Handshake request is always JSON\r\n    writeHandshakeRequest(handshakeRequest) {\r\n        return TextMessageFormat.write(JSON.stringify(handshakeRequest));\r\n    }\r\n    parseHandshakeResponse(data) {\r\n        let messageData;\r\n        let remainingData;\r\n        if (isArrayBuffer(data)) {\r\n            // Format is binary but still need to read JSON text from handshake response\r\n            const binaryData = new Uint8Array(data);\r\n            const separatorIndex = binaryData.indexOf(TextMessageFormat.RecordSeparatorCode);\r\n            if (separatorIndex === -1) {\r\n                throw new Error(\"Message is incomplete.\");\r\n            }\r\n            // content before separator is handshake response\r\n            // optional content after is additional messages\r\n            const responseLength = separatorIndex + 1;\r\n            messageData = String.fromCharCode.apply(null, Array.prototype.slice.call(binaryData.slice(0, responseLength)));\r\n            remainingData = (binaryData.byteLength > responseLength) ? binaryData.slice(responseLength).buffer : null;\r\n        }\r\n        else {\r\n            const textData = data;\r\n            const separatorIndex = textData.indexOf(TextMessageFormat.RecordSeparator);\r\n            if (separatorIndex === -1) {\r\n                throw new Error(\"Message is incomplete.\");\r\n            }\r\n            // content before separator is handshake response\r\n            // optional content after is additional messages\r\n            const responseLength = separatorIndex + 1;\r\n            messageData = textData.substring(0, responseLength);\r\n            remainingData = (textData.length > responseLength) ? textData.substring(responseLength) : null;\r\n        }\r\n        // At this point we should have just the single handshake message\r\n        const messages = TextMessageFormat.parse(messageData);\r\n        const response = JSON.parse(messages[0]);\r\n        if (response.type) {\r\n            throw new Error(\"Expected a handshake response from the server.\");\r\n        }\r\n        const responseMessage = response;\r\n        // multiple messages could have arrived with handshake\r\n        // return additional data to be parsed as usual, or null if all parsed\r\n        return [remainingData, responseMessage];\r\n    }\r\n}\r\n//# sourceMappingURL=HandshakeProtocol.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nexport class HeaderNames {\r\n}\r\nHeaderNames.Authorization = \"Authorization\";\r\nHeaderNames.Cookie = \"Cookie\";\r\n//# sourceMappingURL=HeaderNames.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n/** Represents an HTTP response. */\r\nexport class HttpResponse {\r\n    constructor(statusCode, statusText, content) {\r\n        this.statusCode = statusCode;\r\n        this.statusText = statusText;\r\n        this.content = content;\r\n    }\r\n}\r\n/** Abstraction over an HTTP client.\r\n *\r\n * This class provides an abstraction over an HTTP client so that a different implementation can be provided on different platforms.\r\n */\r\nexport class HttpClient {\r\n    get(url, options) {\r\n        return this.send({\r\n            ...options,\r\n            method: \"GET\",\r\n            url,\r\n        });\r\n    }\r\n    post(url, options) {\r\n        return this.send({\r\n            ...options,\r\n            method: \"POST\",\r\n            url,\r\n        });\r\n    }\r\n    delete(url, options) {\r\n        return this.send({\r\n            ...options,\r\n            method: \"DELETE\",\r\n            url,\r\n        });\r\n    }\r\n    /** Gets all cookies that apply to the specified URL.\r\n     *\r\n     * @param url The URL that the cookies are valid for.\r\n     * @returns {string} A string containing all the key-value cookie pairs for the specified URL.\r\n     */\r\n    // @ts-ignore\r\n    getCookieString(url) {\r\n        return \"\";\r\n    }\r\n}\r\n//# sourceMappingURL=HttpClient.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { AccessTokenHttpClient } from \"./AccessTokenHttpClient\";\r\nimport { DefaultHttpClient } from \"./DefaultHttpClient\";\r\nimport { getEventSource, getWS } from \"./DynamicImports\";\r\nimport { AggregateErrors, DisabledTransportError, FailedToNegotiateWithServerError, FailedToStartTransportError, HttpError, UnsupportedTransportError, AbortError } from \"./Errors\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { HttpTransportType, TransferFormat } from \"./ITransport\";\r\nimport { LongPollingTransport } from \"./LongPollingTransport\";\r\nimport { ServerSentEventsTransport } from \"./ServerSentEventsTransport\";\r\nimport { Arg, createLogger, getUserAgentHeader, Platform } from \"./Utils\";\r\nimport { WebSocketTransport } from \"./WebSocketTransport\";\r\nconst MAX_REDIRECTS = 100;\r\n/** @private */\r\nexport class HttpConnection {\r\n    constructor(url, options = {}) {\r\n        this._stopPromiseResolver = () => { };\r\n        this.features = {};\r\n        this._negotiateVersion = 1;\r\n        Arg.isRequired(url, \"url\");\r\n        this._logger = createLogger(options.logger);\r\n        this.baseUrl = this._resolveUrl(url);\r\n        options = options || {};\r\n        options.logMessageContent = options.logMessageContent === undefined ? false : options.logMessageContent;\r\n        if (typeof options.withCredentials === \"boolean\" || options.withCredentials === undefined) {\r\n            options.withCredentials = options.withCredentials === undefined ? true : options.withCredentials;\r\n        }\r\n        else {\r\n            throw new Error(\"withCredentials option was not a 'boolean' or 'undefined' value\");\r\n        }\r\n        options.timeout = options.timeout === undefined ? 100 * 1000 : options.timeout;\r\n        let webSocketModule = null;\r\n        let eventSourceModule = null;\r\n        if (Platform.isNode && typeof require !== \"undefined\") {\r\n            webSocketModule = getWS();\r\n            eventSourceModule = getEventSource();\r\n        }\r\n        if (!Platform.isNode && typeof WebSocket !== \"undefined\" && !options.WebSocket) {\r\n            options.WebSocket = WebSocket;\r\n        }\r\n        else if (Platform.isNode && !options.WebSocket) {\r\n            if (webSocketModule) {\r\n                options.WebSocket = webSocketModule;\r\n            }\r\n        }\r\n        if (!Platform.isNode && typeof EventSource !== \"undefined\" && !options.EventSource) {\r\n            options.EventSource = EventSource;\r\n        }\r\n        else if (Platform.isNode && !options.EventSource) {\r\n            if (typeof eventSourceModule !== \"undefined\") {\r\n                options.EventSource = eventSourceModule;\r\n            }\r\n        }\r\n        this._httpClient = new AccessTokenHttpClient(options.httpClient || new DefaultHttpClient(this._logger), options.accessTokenFactory);\r\n        this._connectionState = \"Disconnected\" /* ConnectionState.Disconnected */;\r\n        this._connectionStarted = false;\r\n        this._options = options;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n    async start(transferFormat) {\r\n        transferFormat = transferFormat || TransferFormat.Binary;\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._logger.log(LogLevel.Debug, `Starting connection with transfer format '${TransferFormat[transferFormat]}'.`);\r\n        if (this._connectionState !== \"Disconnected\" /* ConnectionState.Disconnected */) {\r\n            return Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n        this._connectionState = \"Connecting\" /* ConnectionState.Connecting */;\r\n        this._startInternalPromise = this._startInternal(transferFormat);\r\n        await this._startInternalPromise;\r\n        // The TypeScript compiler thinks that connectionState must be Connecting here. The TypeScript compiler is wrong.\r\n        if (this._connectionState === \"Disconnecting\" /* ConnectionState.Disconnecting */) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"Failed to start the HttpConnection before stop() was called.\";\r\n            this._logger.log(LogLevel.Error, message);\r\n            // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\r\n            await this._stopPromise;\r\n            return Promise.reject(new AbortError(message));\r\n        }\r\n        else if (this._connectionState !== \"Connected\" /* ConnectionState.Connected */) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\r\n            this._logger.log(LogLevel.Error, message);\r\n            return Promise.reject(new AbortError(message));\r\n        }\r\n        this._connectionStarted = true;\r\n    }\r\n    send(data) {\r\n        if (this._connectionState !== \"Connected\" /* ConnectionState.Connected */) {\r\n            return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\r\n        }\r\n        if (!this._sendQueue) {\r\n            this._sendQueue = new TransportSendQueue(this.transport);\r\n        }\r\n        // Transport will not be null if state is connected\r\n        return this._sendQueue.send(data);\r\n    }\r\n    async stop(error) {\r\n        if (this._connectionState === \"Disconnected\" /* ConnectionState.Disconnected */) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n        if (this._connectionState === \"Disconnecting\" /* ConnectionState.Disconnecting */) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this._stopPromise;\r\n        }\r\n        this._connectionState = \"Disconnecting\" /* ConnectionState.Disconnecting */;\r\n        this._stopPromise = new Promise((resolve) => {\r\n            // Don't complete stop() until stopConnection() completes.\r\n            this._stopPromiseResolver = resolve;\r\n        });\r\n        // stopInternal should never throw so just observe it.\r\n        await this._stopInternal(error);\r\n        await this._stopPromise;\r\n    }\r\n    async _stopInternal(error) {\r\n        // Set error as soon as possible otherwise there is a race between\r\n        // the transport closing and providing an error and the error from a close message\r\n        // We would prefer the close message error.\r\n        this._stopError = error;\r\n        try {\r\n            await this._startInternalPromise;\r\n        }\r\n        catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n        // The transport's onclose will trigger stopConnection which will run our onclose event.\r\n        // The transport should always be set if currently connected. If it wasn't set, it's likely because\r\n        // stop was called during start() and start() failed.\r\n        if (this.transport) {\r\n            try {\r\n                await this.transport.stop();\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Error, `HttpConnection.transport.stop() threw error '${e}'.`);\r\n                this._stopConnection();\r\n            }\r\n            this.transport = undefined;\r\n        }\r\n        else {\r\n            this._logger.log(LogLevel.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\r\n        }\r\n    }\r\n    async _startInternal(transferFormat) {\r\n        // Store the original base url and the access token factory since they may change\r\n        // as part of negotiating\r\n        let url = this.baseUrl;\r\n        this._accessTokenFactory = this._options.accessTokenFactory;\r\n        this._httpClient._accessTokenFactory = this._accessTokenFactory;\r\n        try {\r\n            if (this._options.skipNegotiation) {\r\n                if (this._options.transport === HttpTransportType.WebSockets) {\r\n                    // No need to add a connection ID in this case\r\n                    this.transport = this._constructTransport(HttpTransportType.WebSockets);\r\n                    // We should just call connect directly in this case.\r\n                    // No fallback or negotiate in this case.\r\n                    await this._startTransport(url, transferFormat);\r\n                }\r\n                else {\r\n                    throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\r\n                }\r\n            }\r\n            else {\r\n                let negotiateResponse = null;\r\n                let redirects = 0;\r\n                do {\r\n                    negotiateResponse = await this._getNegotiationResponse(url);\r\n                    // the user tries to stop the connection when it is being started\r\n                    if (this._connectionState === \"Disconnecting\" /* ConnectionState.Disconnecting */ || this._connectionState === \"Disconnected\" /* ConnectionState.Disconnected */) {\r\n                        throw new AbortError(\"The connection was stopped during negotiation.\");\r\n                    }\r\n                    if (negotiateResponse.error) {\r\n                        throw new Error(negotiateResponse.error);\r\n                    }\r\n                    if (negotiateResponse.ProtocolVersion) {\r\n                        throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\r\n                    }\r\n                    if (negotiateResponse.url) {\r\n                        url = negotiateResponse.url;\r\n                    }\r\n                    if (negotiateResponse.accessToken) {\r\n                        // Replace the current access token factory with one that uses\r\n                        // the returned access token\r\n                        const accessToken = negotiateResponse.accessToken;\r\n                        this._accessTokenFactory = () => accessToken;\r\n                        // set the factory to undefined so the AccessTokenHttpClient won't retry with the same token, since we know it won't change until a connection restart\r\n                        this._httpClient._accessToken = accessToken;\r\n                        this._httpClient._accessTokenFactory = undefined;\r\n                    }\r\n                    redirects++;\r\n                } while (negotiateResponse.url && redirects < MAX_REDIRECTS);\r\n                if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\r\n                    throw new Error(\"Negotiate redirection limit exceeded.\");\r\n                }\r\n                await this._createTransport(url, this._options.transport, negotiateResponse, transferFormat);\r\n            }\r\n            if (this.transport instanceof LongPollingTransport) {\r\n                this.features.inherentKeepAlive = true;\r\n            }\r\n            if (this._connectionState === \"Connecting\" /* ConnectionState.Connecting */) {\r\n                // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\r\n                // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\r\n                this._logger.log(LogLevel.Debug, \"The HttpConnection connected successfully.\");\r\n                this._connectionState = \"Connected\" /* ConnectionState.Connected */;\r\n            }\r\n            // stop() is waiting on us via this.startInternalPromise so keep this.transport around so it can clean up.\r\n            // This is the only case startInternal can exit in neither the connected nor disconnected state because stopConnection()\r\n            // will transition to the disconnected state. start() will wait for the transition using the stopPromise.\r\n        }\r\n        catch (e) {\r\n            this._logger.log(LogLevel.Error, \"Failed to start the connection: \" + e);\r\n            this._connectionState = \"Disconnected\" /* ConnectionState.Disconnected */;\r\n            this.transport = undefined;\r\n            // if start fails, any active calls to stop assume that start will complete the stop promise\r\n            this._stopPromiseResolver();\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n    async _getNegotiationResponse(url) {\r\n        const headers = {};\r\n        const [name, value] = getUserAgentHeader();\r\n        headers[name] = value;\r\n        const negotiateUrl = this._resolveNegotiateUrl(url);\r\n        this._logger.log(LogLevel.Debug, `Sending negotiation request: ${negotiateUrl}.`);\r\n        try {\r\n            const response = await this._httpClient.post(negotiateUrl, {\r\n                content: \"\",\r\n                headers: { ...headers, ...this._options.headers },\r\n                timeout: this._options.timeout,\r\n                withCredentials: this._options.withCredentials,\r\n            });\r\n            if (response.statusCode !== 200) {\r\n                return Promise.reject(new Error(`Unexpected status code returned from negotiate '${response.statusCode}'`));\r\n            }\r\n            const negotiateResponse = JSON.parse(response.content);\r\n            if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {\r\n                // Negotiate version 0 doesn't use connectionToken\r\n                // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version\r\n                negotiateResponse.connectionToken = negotiateResponse.connectionId;\r\n            }\r\n            if (negotiateResponse.useStatefulReconnect && this._options._useStatefulReconnect !== true) {\r\n                return Promise.reject(new FailedToNegotiateWithServerError(\"Client didn't negotiate Stateful Reconnect but the server did.\"));\r\n            }\r\n            return negotiateResponse;\r\n        }\r\n        catch (e) {\r\n            let errorMessage = \"Failed to complete negotiation with the server: \" + e;\r\n            if (e instanceof HttpError) {\r\n                if (e.statusCode === 404) {\r\n                    errorMessage = errorMessage + \" Either this is not a SignalR endpoint or there is a proxy blocking the connection.\";\r\n                }\r\n            }\r\n            this._logger.log(LogLevel.Error, errorMessage);\r\n            return Promise.reject(new FailedToNegotiateWithServerError(errorMessage));\r\n        }\r\n    }\r\n    _createConnectUrl(url, connectionToken) {\r\n        if (!connectionToken) {\r\n            return url;\r\n        }\r\n        return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + `id=${connectionToken}`;\r\n    }\r\n    async _createTransport(url, requestedTransport, negotiateResponse, requestedTransferFormat) {\r\n        let connectUrl = this._createConnectUrl(url, negotiateResponse.connectionToken);\r\n        if (this._isITransport(requestedTransport)) {\r\n            this._logger.log(LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\r\n            this.transport = requestedTransport;\r\n            await this._startTransport(connectUrl, requestedTransferFormat);\r\n            this.connectionId = negotiateResponse.connectionId;\r\n            return;\r\n        }\r\n        const transportExceptions = [];\r\n        const transports = negotiateResponse.availableTransports || [];\r\n        let negotiate = negotiateResponse;\r\n        for (const endpoint of transports) {\r\n            const transportOrError = this._resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat, (negotiate === null || negotiate === void 0 ? void 0 : negotiate.useStatefulReconnect) === true);\r\n            if (transportOrError instanceof Error) {\r\n                // Store the error and continue, we don't want to cause a re-negotiate in these cases\r\n                transportExceptions.push(`${endpoint.transport} failed:`);\r\n                transportExceptions.push(transportOrError);\r\n            }\r\n            else if (this._isITransport(transportOrError)) {\r\n                this.transport = transportOrError;\r\n                if (!negotiate) {\r\n                    try {\r\n                        negotiate = await this._getNegotiationResponse(url);\r\n                    }\r\n                    catch (ex) {\r\n                        return Promise.reject(ex);\r\n                    }\r\n                    connectUrl = this._createConnectUrl(url, negotiate.connectionToken);\r\n                }\r\n                try {\r\n                    await this._startTransport(connectUrl, requestedTransferFormat);\r\n                    this.connectionId = negotiate.connectionId;\r\n                    return;\r\n                }\r\n                catch (ex) {\r\n                    this._logger.log(LogLevel.Error, `Failed to start the transport '${endpoint.transport}': ${ex}`);\r\n                    negotiate = undefined;\r\n                    transportExceptions.push(new FailedToStartTransportError(`${endpoint.transport} failed: ${ex}`, HttpTransportType[endpoint.transport]));\r\n                    if (this._connectionState !== \"Connecting\" /* ConnectionState.Connecting */) {\r\n                        const message = \"Failed to select transport before stop() was called.\";\r\n                        this._logger.log(LogLevel.Debug, message);\r\n                        return Promise.reject(new AbortError(message));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (transportExceptions.length > 0) {\r\n            return Promise.reject(new AggregateErrors(`Unable to connect to the server with any of the available transports. ${transportExceptions.join(\" \")}`, transportExceptions));\r\n        }\r\n        return Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"));\r\n    }\r\n    _constructTransport(transport) {\r\n        switch (transport) {\r\n            case HttpTransportType.WebSockets:\r\n                if (!this._options.WebSocket) {\r\n                    throw new Error(\"'WebSocket' is not supported in your environment.\");\r\n                }\r\n                return new WebSocketTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options.logMessageContent, this._options.WebSocket, this._options.headers || {});\r\n            case HttpTransportType.ServerSentEvents:\r\n                if (!this._options.EventSource) {\r\n                    throw new Error(\"'EventSource' is not supported in your environment.\");\r\n                }\r\n                return new ServerSentEventsTransport(this._httpClient, this._httpClient._accessToken, this._logger, this._options);\r\n            case HttpTransportType.LongPolling:\r\n                return new LongPollingTransport(this._httpClient, this._logger, this._options);\r\n            default:\r\n                throw new Error(`Unknown transport: ${transport}.`);\r\n        }\r\n    }\r\n    _startTransport(url, transferFormat) {\r\n        this.transport.onreceive = this.onreceive;\r\n        if (this.features.reconnect) {\r\n            this.transport.onclose = async (e) => {\r\n                let callStop = false;\r\n                if (this.features.reconnect) {\r\n                    try {\r\n                        this.features.disconnected();\r\n                        await this.transport.connect(url, transferFormat);\r\n                        await this.features.resend();\r\n                    }\r\n                    catch {\r\n                        callStop = true;\r\n                    }\r\n                }\r\n                else {\r\n                    this._stopConnection(e);\r\n                    return;\r\n                }\r\n                if (callStop) {\r\n                    this._stopConnection(e);\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            this.transport.onclose = (e) => this._stopConnection(e);\r\n        }\r\n        return this.transport.connect(url, transferFormat);\r\n    }\r\n    _resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat, useStatefulReconnect) {\r\n        const transport = HttpTransportType[endpoint.transport];\r\n        if (transport === null || transport === undefined) {\r\n            this._logger.log(LogLevel.Debug, `Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n            return new Error(`Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n        }\r\n        else {\r\n            if (transportMatches(requestedTransport, transport)) {\r\n                const transferFormats = endpoint.transferFormats.map((s) => TransferFormat[s]);\r\n                if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\r\n                    if ((transport === HttpTransportType.WebSockets && !this._options.WebSocket) ||\r\n                        (transport === HttpTransportType.ServerSentEvents && !this._options.EventSource)) {\r\n                        this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it is not supported in your environment.'`);\r\n                        return new UnsupportedTransportError(`'${HttpTransportType[transport]}' is not supported in your environment.`, transport);\r\n                    }\r\n                    else {\r\n                        this._logger.log(LogLevel.Debug, `Selecting transport '${HttpTransportType[transport]}'.`);\r\n                        try {\r\n                            this.features.reconnect = transport === HttpTransportType.WebSockets ? useStatefulReconnect : undefined;\r\n                            return this._constructTransport(transport);\r\n                        }\r\n                        catch (ex) {\r\n                            return ex;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it does not support the requested transfer format '${TransferFormat[requestedTransferFormat]}'.`);\r\n                    return new Error(`'${HttpTransportType[transport]}' does not support ${TransferFormat[requestedTransferFormat]}.`);\r\n                }\r\n            }\r\n            else {\r\n                this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it was disabled by the client.`);\r\n                return new DisabledTransportError(`'${HttpTransportType[transport]}' is disabled by the client.`, transport);\r\n            }\r\n        }\r\n    }\r\n    _isITransport(transport) {\r\n        return transport && typeof (transport) === \"object\" && \"connect\" in transport;\r\n    }\r\n    _stopConnection(error) {\r\n        this._logger.log(LogLevel.Debug, `HttpConnection.stopConnection(${error}) called while in state ${this._connectionState}.`);\r\n        this.transport = undefined;\r\n        // If we have a stopError, it takes precedence over the error from the transport\r\n        error = this._stopError || error;\r\n        this._stopError = undefined;\r\n        if (this._connectionState === \"Disconnected\" /* ConnectionState.Disconnected */) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is already in the disconnected state.`);\r\n            return;\r\n        }\r\n        if (this._connectionState === \"Connecting\" /* ConnectionState.Connecting */) {\r\n            this._logger.log(LogLevel.Warning, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is still in the connecting state.`);\r\n            throw new Error(`HttpConnection.stopConnection(${error}) was called while the connection is still in the connecting state.`);\r\n        }\r\n        if (this._connectionState === \"Disconnecting\" /* ConnectionState.Disconnecting */) {\r\n            // A call to stop() induced this call to stopConnection and needs to be completed.\r\n            // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\r\n            this._stopPromiseResolver();\r\n        }\r\n        if (error) {\r\n            this._logger.log(LogLevel.Error, `Connection disconnected with error '${error}'.`);\r\n        }\r\n        else {\r\n            this._logger.log(LogLevel.Information, \"Connection disconnected.\");\r\n        }\r\n        if (this._sendQueue) {\r\n            this._sendQueue.stop().catch((e) => {\r\n                this._logger.log(LogLevel.Error, `TransportSendQueue.stop() threw error '${e}'.`);\r\n            });\r\n            this._sendQueue = undefined;\r\n        }\r\n        this.connectionId = undefined;\r\n        this._connectionState = \"Disconnected\" /* ConnectionState.Disconnected */;\r\n        if (this._connectionStarted) {\r\n            this._connectionStarted = false;\r\n            try {\r\n                if (this.onclose) {\r\n                    this.onclose(error);\r\n                }\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Error, `HttpConnection.onclose(${error}) threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n    _resolveUrl(url) {\r\n        // startsWith is not supported in IE\r\n        if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\r\n            return url;\r\n        }\r\n        if (!Platform.isBrowser) {\r\n            throw new Error(`Cannot resolve '${url}'.`);\r\n        }\r\n        // Setting the url to the href propery of an anchor tag handles normalization\r\n        // for us. There are 3 main cases.\r\n        // 1. Relative path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\r\n        // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\r\n        // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\r\n        const aTag = window.document.createElement(\"a\");\r\n        aTag.href = url;\r\n        this._logger.log(LogLevel.Information, `Normalizing '${url}' to '${aTag.href}'.`);\r\n        return aTag.href;\r\n    }\r\n    _resolveNegotiateUrl(url) {\r\n        const negotiateUrl = new URL(url);\r\n        if (negotiateUrl.pathname.endsWith('/')) {\r\n            negotiateUrl.pathname += \"negotiate\";\r\n        }\r\n        else {\r\n            negotiateUrl.pathname += \"/negotiate\";\r\n        }\r\n        const searchParams = new URLSearchParams(negotiateUrl.searchParams);\r\n        if (!searchParams.has(\"negotiateVersion\")) {\r\n            searchParams.append(\"negotiateVersion\", this._negotiateVersion.toString());\r\n        }\r\n        if (searchParams.has(\"useStatefulReconnect\")) {\r\n            if (searchParams.get(\"useStatefulReconnect\") === \"true\") {\r\n                this._options._useStatefulReconnect = true;\r\n            }\r\n        }\r\n        else if (this._options._useStatefulReconnect === true) {\r\n            searchParams.append(\"useStatefulReconnect\", \"true\");\r\n        }\r\n        negotiateUrl.search = searchParams.toString();\r\n        return negotiateUrl.toString();\r\n    }\r\n}\r\nfunction transportMatches(requestedTransport, actualTransport) {\r\n    return !requestedTransport || ((actualTransport & requestedTransport) !== 0);\r\n}\r\n/** @private */\r\nexport class TransportSendQueue {\r\n    constructor(_transport) {\r\n        this._transport = _transport;\r\n        this._buffer = [];\r\n        this._executing = true;\r\n        this._sendBufferedData = new PromiseSource();\r\n        this._transportResult = new PromiseSource();\r\n        this._sendLoopPromise = this._sendLoop();\r\n    }\r\n    send(data) {\r\n        this._bufferData(data);\r\n        if (!this._transportResult) {\r\n            this._transportResult = new PromiseSource();\r\n        }\r\n        return this._transportResult.promise;\r\n    }\r\n    stop() {\r\n        this._executing = false;\r\n        this._sendBufferedData.resolve();\r\n        return this._sendLoopPromise;\r\n    }\r\n    _bufferData(data) {\r\n        if (this._buffer.length && typeof (this._buffer[0]) !== typeof (data)) {\r\n            throw new Error(`Expected data to be of type ${typeof (this._buffer)} but was of type ${typeof (data)}`);\r\n        }\r\n        this._buffer.push(data);\r\n        this._sendBufferedData.resolve();\r\n    }\r\n    async _sendLoop() {\r\n        while (true) {\r\n            await this._sendBufferedData.promise;\r\n            if (!this._executing) {\r\n                if (this._transportResult) {\r\n                    this._transportResult.reject(\"Connection stopped.\");\r\n                }\r\n                break;\r\n            }\r\n            this._sendBufferedData = new PromiseSource();\r\n            const transportResult = this._transportResult;\r\n            this._transportResult = undefined;\r\n            const data = typeof (this._buffer[0]) === \"string\" ?\r\n                this._buffer.join(\"\") :\r\n                TransportSendQueue._concatBuffers(this._buffer);\r\n            this._buffer.length = 0;\r\n            try {\r\n                await this._transport.send(data);\r\n                transportResult.resolve();\r\n            }\r\n            catch (error) {\r\n                transportResult.reject(error);\r\n            }\r\n        }\r\n    }\r\n    static _concatBuffers(arrayBuffers) {\r\n        const totalLength = arrayBuffers.map((b) => b.byteLength).reduce((a, b) => a + b);\r\n        const result = new Uint8Array(totalLength);\r\n        let offset = 0;\r\n        for (const item of arrayBuffers) {\r\n            result.set(new Uint8Array(item), offset);\r\n            offset += item.byteLength;\r\n        }\r\n        return result.buffer;\r\n    }\r\n}\r\nclass PromiseSource {\r\n    constructor() {\r\n        this.promise = new Promise((resolve, reject) => [this._resolver, this._rejecter] = [resolve, reject]);\r\n    }\r\n    resolve() {\r\n        this._resolver();\r\n    }\r\n    reject(reason) {\r\n        this._rejecter(reason);\r\n    }\r\n}\r\n//# sourceMappingURL=HttpConnection.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { HandshakeProtocol } from \"./HandshakeProtocol\";\r\nimport { AbortError } from \"./Errors\";\r\nimport { MessageType } from \"./IHubProtocol\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { Subject } from \"./Subject\";\r\nimport { Arg, getErrorString, Platform } from \"./Utils\";\r\nimport { MessageBuffer } from \"./MessageBuffer\";\r\nconst DEFAULT_TIMEOUT_IN_MS = 30 * 1000;\r\nconst DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;\r\nconst DEFAULT_STATEFUL_RECONNECT_BUFFER_SIZE = 100000;\r\n/** Describes the current state of the {@link HubConnection} to the server. */\r\nexport var HubConnectionState;\r\n(function (HubConnectionState) {\r\n    /** The hub connection is disconnected. */\r\n    HubConnectionState[\"Disconnected\"] = \"Disconnected\";\r\n    /** The hub connection is connecting. */\r\n    HubConnectionState[\"Connecting\"] = \"Connecting\";\r\n    /** The hub connection is connected. */\r\n    HubConnectionState[\"Connected\"] = \"Connected\";\r\n    /** The hub connection is disconnecting. */\r\n    HubConnectionState[\"Disconnecting\"] = \"Disconnecting\";\r\n    /** The hub connection is reconnecting. */\r\n    HubConnectionState[\"Reconnecting\"] = \"Reconnecting\";\r\n})(HubConnectionState || (HubConnectionState = {}));\r\n/** Represents a connection to a SignalR Hub. */\r\nexport class HubConnection {\r\n    /** @internal */\r\n    // Using a public static factory method means we can have a private constructor and an _internal_\r\n    // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\r\n    // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\r\n    // public parameter-less constructor.\r\n    static create(connection, logger, protocol, reconnectPolicy, serverTimeoutInMilliseconds, keepAliveIntervalInMilliseconds, statefulReconnectBufferSize) {\r\n        return new HubConnection(connection, logger, protocol, reconnectPolicy, serverTimeoutInMilliseconds, keepAliveIntervalInMilliseconds, statefulReconnectBufferSize);\r\n    }\r\n    constructor(connection, logger, protocol, reconnectPolicy, serverTimeoutInMilliseconds, keepAliveIntervalInMilliseconds, statefulReconnectBufferSize) {\r\n        this._nextKeepAlive = 0;\r\n        this._freezeEventListener = () => {\r\n            this._logger.log(LogLevel.Warning, \"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep\");\r\n        };\r\n        Arg.isRequired(connection, \"connection\");\r\n        Arg.isRequired(logger, \"logger\");\r\n        Arg.isRequired(protocol, \"protocol\");\r\n        this.serverTimeoutInMilliseconds = serverTimeoutInMilliseconds !== null && serverTimeoutInMilliseconds !== void 0 ? serverTimeoutInMilliseconds : DEFAULT_TIMEOUT_IN_MS;\r\n        this.keepAliveIntervalInMilliseconds = keepAliveIntervalInMilliseconds !== null && keepAliveIntervalInMilliseconds !== void 0 ? keepAliveIntervalInMilliseconds : DEFAULT_PING_INTERVAL_IN_MS;\r\n        this._statefulReconnectBufferSize = statefulReconnectBufferSize !== null && statefulReconnectBufferSize !== void 0 ? statefulReconnectBufferSize : DEFAULT_STATEFUL_RECONNECT_BUFFER_SIZE;\r\n        this._logger = logger;\r\n        this._protocol = protocol;\r\n        this.connection = connection;\r\n        this._reconnectPolicy = reconnectPolicy;\r\n        this._handshakeProtocol = new HandshakeProtocol();\r\n        this.connection.onreceive = (data) => this._processIncomingData(data);\r\n        this.connection.onclose = (error) => this._connectionClosed(error);\r\n        this._callbacks = {};\r\n        this._methods = {};\r\n        this._closedCallbacks = [];\r\n        this._reconnectingCallbacks = [];\r\n        this._reconnectedCallbacks = [];\r\n        this._invocationId = 0;\r\n        this._receivedHandshakeResponse = false;\r\n        this._connectionState = HubConnectionState.Disconnected;\r\n        this._connectionStarted = false;\r\n        this._cachedPingMessage = this._protocol.writeMessage({ type: MessageType.Ping });\r\n    }\r\n    /** Indicates the state of the {@link HubConnection} to the server. */\r\n    get state() {\r\n        return this._connectionState;\r\n    }\r\n    /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\r\n     *  in the disconnected state or if the negotiation step was skipped.\r\n     */\r\n    get connectionId() {\r\n        return this.connection ? (this.connection.connectionId || null) : null;\r\n    }\r\n    /** Indicates the url of the {@link HubConnection} to the server. */\r\n    get baseUrl() {\r\n        return this.connection.baseUrl || \"\";\r\n    }\r\n    /**\r\n     * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\r\n     * Reconnecting states.\r\n     * @param {string} url The url to connect to.\r\n     */\r\n    set baseUrl(url) {\r\n        if (this._connectionState !== HubConnectionState.Disconnected && this._connectionState !== HubConnectionState.Reconnecting) {\r\n            throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\r\n        }\r\n        if (!url) {\r\n            throw new Error(\"The HubConnection url must be a valid url.\");\r\n        }\r\n        this.connection.baseUrl = url;\r\n    }\r\n    /** Starts the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n     */\r\n    start() {\r\n        this._startPromise = this._startWithStateTransitions();\r\n        return this._startPromise;\r\n    }\r\n    async _startWithStateTransitions() {\r\n        if (this._connectionState !== HubConnectionState.Disconnected) {\r\n            return Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n        this._connectionState = HubConnectionState.Connecting;\r\n        this._logger.log(LogLevel.Debug, \"Starting HubConnection.\");\r\n        try {\r\n            await this._startInternal();\r\n            if (Platform.isBrowser) {\r\n                // Log when the browser freezes the tab so users know why their connection unexpectedly stopped working\r\n                window.document.addEventListener(\"freeze\", this._freezeEventListener);\r\n            }\r\n            this._connectionState = HubConnectionState.Connected;\r\n            this._connectionStarted = true;\r\n            this._logger.log(LogLevel.Debug, \"HubConnection connected successfully.\");\r\n        }\r\n        catch (e) {\r\n            this._connectionState = HubConnectionState.Disconnected;\r\n            this._logger.log(LogLevel.Debug, `HubConnection failed to start successfully because of error '${e}'.`);\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n    async _startInternal() {\r\n        this._stopDuringStartError = undefined;\r\n        this._receivedHandshakeResponse = false;\r\n        // Set up the promise before any connection is (re)started otherwise it could race with received messages\r\n        const handshakePromise = new Promise((resolve, reject) => {\r\n            this._handshakeResolver = resolve;\r\n            this._handshakeRejecter = reject;\r\n        });\r\n        await this.connection.start(this._protocol.transferFormat);\r\n        try {\r\n            let version = this._protocol.version;\r\n            if (!this.connection.features.reconnect) {\r\n                // Stateful Reconnect starts with HubProtocol version 2, newer clients connecting to older servers will fail to connect due to\r\n                // the handshake only supporting version 1, so we will try to send version 1 during the handshake to keep old servers working.\r\n                version = 1;\r\n            }\r\n            const handshakeRequest = {\r\n                protocol: this._protocol.name,\r\n                version,\r\n            };\r\n            this._logger.log(LogLevel.Debug, \"Sending handshake request.\");\r\n            await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(handshakeRequest));\r\n            this._logger.log(LogLevel.Information, `Using HubProtocol '${this._protocol.name}'.`);\r\n            // defensively cleanup timeout in case we receive a message from the server before we finish start\r\n            this._cleanupTimeout();\r\n            this._resetTimeoutPeriod();\r\n            this._resetKeepAliveInterval();\r\n            await handshakePromise;\r\n            // It's important to check the stopDuringStartError instead of just relying on the handshakePromise\r\n            // being rejected on close, because this continuation can run after both the handshake completed successfully\r\n            // and the connection was closed.\r\n            if (this._stopDuringStartError) {\r\n                // It's important to throw instead of returning a rejected promise, because we don't want to allow any state\r\n                // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise\r\n                // will cause the calling continuation to get scheduled to run later.\r\n                // eslint-disable-next-line @typescript-eslint/no-throw-literal\r\n                throw this._stopDuringStartError;\r\n            }\r\n            const useStatefulReconnect = this.connection.features.reconnect || false;\r\n            if (useStatefulReconnect) {\r\n                this._messageBuffer = new MessageBuffer(this._protocol, this.connection, this._statefulReconnectBufferSize);\r\n                this.connection.features.disconnected = this._messageBuffer._disconnected.bind(this._messageBuffer);\r\n                this.connection.features.resend = () => {\r\n                    if (this._messageBuffer) {\r\n                        return this._messageBuffer._resend();\r\n                    }\r\n                };\r\n            }\r\n            if (!this.connection.features.inherentKeepAlive) {\r\n                await this._sendMessage(this._cachedPingMessage);\r\n            }\r\n        }\r\n        catch (e) {\r\n            this._logger.log(LogLevel.Debug, `Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`);\r\n            this._cleanupTimeout();\r\n            this._cleanupPingTimer();\r\n            // HttpConnection.stop() should not complete until after the onclose callback is invoked.\r\n            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\r\n            await this.connection.stop(e);\r\n            throw e;\r\n        }\r\n    }\r\n    /** Stops the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n     */\r\n    async stop() {\r\n        // Capture the start promise before the connection might be restarted in an onclose callback.\r\n        const startPromise = this._startPromise;\r\n        this.connection.features.reconnect = false;\r\n        this._stopPromise = this._stopInternal();\r\n        await this._stopPromise;\r\n        try {\r\n            // Awaiting undefined continues immediately\r\n            await startPromise;\r\n        }\r\n        catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n    }\r\n    _stopInternal(error) {\r\n        if (this._connectionState === HubConnectionState.Disconnected) {\r\n            this._logger.log(LogLevel.Debug, `Call to HubConnection.stop(${error}) ignored because it is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n        if (this._connectionState === HubConnectionState.Disconnecting) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this._stopPromise;\r\n        }\r\n        const state = this._connectionState;\r\n        this._connectionState = HubConnectionState.Disconnecting;\r\n        this._logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\r\n        if (this._reconnectDelayHandle) {\r\n            // We're in a reconnect delay which means the underlying connection is currently already stopped.\r\n            // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\r\n            // fire the onclose callbacks.\r\n            this._logger.log(LogLevel.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\r\n            clearTimeout(this._reconnectDelayHandle);\r\n            this._reconnectDelayHandle = undefined;\r\n            this._completeClose();\r\n            return Promise.resolve();\r\n        }\r\n        if (state === HubConnectionState.Connected) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._sendCloseMessage();\r\n        }\r\n        this._cleanupTimeout();\r\n        this._cleanupPingTimer();\r\n        this._stopDuringStartError = error || new AbortError(\"The connection was stopped before the hub handshake could complete.\");\r\n        // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\r\n        // or the onclose callback is invoked. The onclose callback will transition the HubConnection\r\n        // to the disconnected state if need be before HttpConnection.stop() completes.\r\n        return this.connection.stop(error);\r\n    }\r\n    async _sendCloseMessage() {\r\n        try {\r\n            await this._sendWithProtocol(this._createCloseMessage());\r\n        }\r\n        catch {\r\n            // Ignore, this is a best effort attempt to let the server know the client closed gracefully.\r\n        }\r\n    }\r\n    /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n     *\r\n     * @typeparam T The type of the items returned by the server.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n     */\r\n    stream(methodName, ...args) {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const invocationDescriptor = this._createStreamInvocation(methodName, args, streamIds);\r\n        // eslint-disable-next-line prefer-const\r\n        let promiseQueue;\r\n        const subject = new Subject();\r\n        subject.cancelCallback = () => {\r\n            const cancelInvocation = this._createCancelInvocation(invocationDescriptor.invocationId);\r\n            delete this._callbacks[invocationDescriptor.invocationId];\r\n            return promiseQueue.then(() => {\r\n                return this._sendWithProtocol(cancelInvocation);\r\n            });\r\n        };\r\n        this._callbacks[invocationDescriptor.invocationId] = (invocationEvent, error) => {\r\n            if (error) {\r\n                subject.error(error);\r\n                return;\r\n            }\r\n            else if (invocationEvent) {\r\n                // invocationEvent will not be null when an error is not passed to the callback\r\n                if (invocationEvent.type === MessageType.Completion) {\r\n                    if (invocationEvent.error) {\r\n                        subject.error(new Error(invocationEvent.error));\r\n                    }\r\n                    else {\r\n                        subject.complete();\r\n                    }\r\n                }\r\n                else {\r\n                    subject.next((invocationEvent.item));\r\n                }\r\n            }\r\n        };\r\n        promiseQueue = this._sendWithProtocol(invocationDescriptor)\r\n            .catch((e) => {\r\n            subject.error(e);\r\n            delete this._callbacks[invocationDescriptor.invocationId];\r\n        });\r\n        this._launchStreams(streams, promiseQueue);\r\n        return subject;\r\n    }\r\n    _sendMessage(message) {\r\n        this._resetKeepAliveInterval();\r\n        return this.connection.send(message);\r\n    }\r\n    /**\r\n     * Sends a js object to the server.\r\n     * @param message The js object to serialize and send.\r\n     */\r\n    _sendWithProtocol(message) {\r\n        if (this._messageBuffer) {\r\n            return this._messageBuffer._send(message);\r\n        }\r\n        else {\r\n            return this._sendMessage(this._protocol.writeMessage(message));\r\n        }\r\n    }\r\n    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n     *\r\n     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n     * be processing the invocation.\r\n     *\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n     */\r\n    send(methodName, ...args) {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const sendPromise = this._sendWithProtocol(this._createInvocation(methodName, args, true, streamIds));\r\n        this._launchStreams(streams, sendPromise);\r\n        return sendPromise;\r\n    }\r\n    /** Invokes a hub method on the server using the specified name and arguments.\r\n     *\r\n     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n     * resolving the Promise.\r\n     *\r\n     * @typeparam T The expected return type.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n     */\r\n    invoke(methodName, ...args) {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const invocationDescriptor = this._createInvocation(methodName, args, false, streamIds);\r\n        const p = new Promise((resolve, reject) => {\r\n            // invocationId will always have a value for a non-blocking invocation\r\n            this._callbacks[invocationDescriptor.invocationId] = (invocationEvent, error) => {\r\n                if (error) {\r\n                    reject(error);\r\n                    return;\r\n                }\r\n                else if (invocationEvent) {\r\n                    // invocationEvent will not be null when an error is not passed to the callback\r\n                    if (invocationEvent.type === MessageType.Completion) {\r\n                        if (invocationEvent.error) {\r\n                            reject(new Error(invocationEvent.error));\r\n                        }\r\n                        else {\r\n                            resolve(invocationEvent.result);\r\n                        }\r\n                    }\r\n                    else {\r\n                        reject(new Error(`Unexpected message type: ${invocationEvent.type}`));\r\n                    }\r\n                }\r\n            };\r\n            const promiseQueue = this._sendWithProtocol(invocationDescriptor)\r\n                .catch((e) => {\r\n                reject(e);\r\n                // invocationId will always have a value for a non-blocking invocation\r\n                delete this._callbacks[invocationDescriptor.invocationId];\r\n            });\r\n            this._launchStreams(streams, promiseQueue);\r\n        });\r\n        return p;\r\n    }\r\n    on(methodName, newMethod) {\r\n        if (!methodName || !newMethod) {\r\n            return;\r\n        }\r\n        methodName = methodName.toLowerCase();\r\n        if (!this._methods[methodName]) {\r\n            this._methods[methodName] = [];\r\n        }\r\n        // Preventing adding the same handler multiple times.\r\n        if (this._methods[methodName].indexOf(newMethod) !== -1) {\r\n            return;\r\n        }\r\n        this._methods[methodName].push(newMethod);\r\n    }\r\n    off(methodName, method) {\r\n        if (!methodName) {\r\n            return;\r\n        }\r\n        methodName = methodName.toLowerCase();\r\n        const handlers = this._methods[methodName];\r\n        if (!handlers) {\r\n            return;\r\n        }\r\n        if (method) {\r\n            const removeIdx = handlers.indexOf(method);\r\n            if (removeIdx !== -1) {\r\n                handlers.splice(removeIdx, 1);\r\n                if (handlers.length === 0) {\r\n                    delete this._methods[methodName];\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            delete this._methods[methodName];\r\n        }\r\n    }\r\n    /** Registers a handler that will be invoked when the connection is closed.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n     */\r\n    onclose(callback) {\r\n        if (callback) {\r\n            this._closedCallbacks.push(callback);\r\n        }\r\n    }\r\n    /** Registers a handler that will be invoked when the connection starts reconnecting.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\r\n     */\r\n    onreconnecting(callback) {\r\n        if (callback) {\r\n            this._reconnectingCallbacks.push(callback);\r\n        }\r\n    }\r\n    /** Registers a handler that will be invoked when the connection successfully reconnects.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\r\n     */\r\n    onreconnected(callback) {\r\n        if (callback) {\r\n            this._reconnectedCallbacks.push(callback);\r\n        }\r\n    }\r\n    _processIncomingData(data) {\r\n        this._cleanupTimeout();\r\n        if (!this._receivedHandshakeResponse) {\r\n            data = this._processHandshakeResponse(data);\r\n            this._receivedHandshakeResponse = true;\r\n        }\r\n        // Data may have all been read when processing handshake response\r\n        if (data) {\r\n            // Parse the messages\r\n            const messages = this._protocol.parseMessages(data, this._logger);\r\n            for (const message of messages) {\r\n                if (this._messageBuffer && !this._messageBuffer._shouldProcessMessage(message)) {\r\n                    // Don't process the message, we are either waiting for a SequenceMessage or received a duplicate message\r\n                    continue;\r\n                }\r\n                switch (message.type) {\r\n                    case MessageType.Invocation:\r\n                        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n                        this._invokeClientMethod(message);\r\n                        break;\r\n                    case MessageType.StreamItem:\r\n                    case MessageType.Completion: {\r\n                        const callback = this._callbacks[message.invocationId];\r\n                        if (callback) {\r\n                            if (message.type === MessageType.Completion) {\r\n                                delete this._callbacks[message.invocationId];\r\n                            }\r\n                            try {\r\n                                callback(message);\r\n                            }\r\n                            catch (e) {\r\n                                this._logger.log(LogLevel.Error, `Stream callback threw error: ${getErrorString(e)}`);\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case MessageType.Ping:\r\n                        // Don't care about pings\r\n                        break;\r\n                    case MessageType.Close: {\r\n                        this._logger.log(LogLevel.Information, \"Close message received from server.\");\r\n                        const error = message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined;\r\n                        if (message.allowReconnect === true) {\r\n                            // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,\r\n                            // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.\r\n                            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n                            this.connection.stop(error);\r\n                        }\r\n                        else {\r\n                            // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.\r\n                            this._stopPromise = this._stopInternal(error);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case MessageType.Ack:\r\n                        if (this._messageBuffer) {\r\n                            this._messageBuffer._ack(message);\r\n                        }\r\n                        break;\r\n                    case MessageType.Sequence:\r\n                        if (this._messageBuffer) {\r\n                            this._messageBuffer._resetSequence(message);\r\n                        }\r\n                        break;\r\n                    default:\r\n                        this._logger.log(LogLevel.Warning, `Invalid message type: ${message.type}.`);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        this._resetTimeoutPeriod();\r\n    }\r\n    _processHandshakeResponse(data) {\r\n        let responseMessage;\r\n        let remainingData;\r\n        try {\r\n            [remainingData, responseMessage] = this._handshakeProtocol.parseHandshakeResponse(data);\r\n        }\r\n        catch (e) {\r\n            const message = \"Error parsing handshake response: \" + e;\r\n            this._logger.log(LogLevel.Error, message);\r\n            const error = new Error(message);\r\n            this._handshakeRejecter(error);\r\n            throw error;\r\n        }\r\n        if (responseMessage.error) {\r\n            const message = \"Server returned handshake error: \" + responseMessage.error;\r\n            this._logger.log(LogLevel.Error, message);\r\n            const error = new Error(message);\r\n            this._handshakeRejecter(error);\r\n            throw error;\r\n        }\r\n        else {\r\n            this._logger.log(LogLevel.Debug, \"Server handshake complete.\");\r\n        }\r\n        this._handshakeResolver();\r\n        return remainingData;\r\n    }\r\n    _resetKeepAliveInterval() {\r\n        if (this.connection.features.inherentKeepAlive) {\r\n            return;\r\n        }\r\n        // Set the time we want the next keep alive to be sent\r\n        // Timer will be setup on next message receive\r\n        this._nextKeepAlive = new Date().getTime() + this.keepAliveIntervalInMilliseconds;\r\n        this._cleanupPingTimer();\r\n    }\r\n    _resetTimeoutPeriod() {\r\n        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\r\n            // Set the timeout timer\r\n            this._timeoutHandle = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds);\r\n            // Set keepAlive timer if there isn't one\r\n            if (this._pingServerHandle === undefined) {\r\n                let nextPing = this._nextKeepAlive - new Date().getTime();\r\n                if (nextPing < 0) {\r\n                    nextPing = 0;\r\n                }\r\n                // The timer needs to be set from a networking callback to avoid Chrome timer throttling from causing timers to run once a minute\r\n                this._pingServerHandle = setTimeout(async () => {\r\n                    if (this._connectionState === HubConnectionState.Connected) {\r\n                        try {\r\n                            await this._sendMessage(this._cachedPingMessage);\r\n                        }\r\n                        catch {\r\n                            // We don't care about the error. It should be seen elsewhere in the client.\r\n                            // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\r\n                            this._cleanupPingTimer();\r\n                        }\r\n                    }\r\n                }, nextPing);\r\n            }\r\n        }\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    serverTimeout() {\r\n        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\r\n        // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\r\n    }\r\n    async _invokeClientMethod(invocationMessage) {\r\n        const methodName = invocationMessage.target.toLowerCase();\r\n        const methods = this._methods[methodName];\r\n        if (!methods) {\r\n            this._logger.log(LogLevel.Warning, `No client method with the name '${methodName}' found.`);\r\n            // No handlers provided by client but the server is expecting a response still, so we send an error\r\n            if (invocationMessage.invocationId) {\r\n                this._logger.log(LogLevel.Warning, `No result given for '${methodName}' method and invocation ID '${invocationMessage.invocationId}'.`);\r\n                await this._sendWithProtocol(this._createCompletionMessage(invocationMessage.invocationId, \"Client didn't provide a result.\", null));\r\n            }\r\n            return;\r\n        }\r\n        // Avoid issues with handlers removing themselves thus modifying the list while iterating through it\r\n        const methodsCopy = methods.slice();\r\n        // Server expects a response\r\n        const expectsResponse = invocationMessage.invocationId ? true : false;\r\n        // We preserve the last result or exception but still call all handlers\r\n        let res;\r\n        let exception;\r\n        let completionMessage;\r\n        for (const m of methodsCopy) {\r\n            try {\r\n                const prevRes = res;\r\n                res = await m.apply(this, invocationMessage.arguments);\r\n                if (expectsResponse && res && prevRes) {\r\n                    this._logger.log(LogLevel.Error, `Multiple results provided for '${methodName}'. Sending error to server.`);\r\n                    completionMessage = this._createCompletionMessage(invocationMessage.invocationId, `Client provided multiple results.`, null);\r\n                }\r\n                // Ignore exception if we got a result after, the exception will be logged\r\n                exception = undefined;\r\n            }\r\n            catch (e) {\r\n                exception = e;\r\n                this._logger.log(LogLevel.Error, `A callback for the method '${methodName}' threw error '${e}'.`);\r\n            }\r\n        }\r\n        if (completionMessage) {\r\n            await this._sendWithProtocol(completionMessage);\r\n        }\r\n        else if (expectsResponse) {\r\n            // If there is an exception that means either no result was given or a handler after a result threw\r\n            if (exception) {\r\n                completionMessage = this._createCompletionMessage(invocationMessage.invocationId, `${exception}`, null);\r\n            }\r\n            else if (res !== undefined) {\r\n                completionMessage = this._createCompletionMessage(invocationMessage.invocationId, null, res);\r\n            }\r\n            else {\r\n                this._logger.log(LogLevel.Warning, `No result given for '${methodName}' method and invocation ID '${invocationMessage.invocationId}'.`);\r\n                // Client didn't provide a result or throw from a handler, server expects a response so we send an error\r\n                completionMessage = this._createCompletionMessage(invocationMessage.invocationId, \"Client didn't provide a result.\", null);\r\n            }\r\n            await this._sendWithProtocol(completionMessage);\r\n        }\r\n        else {\r\n            if (res) {\r\n                this._logger.log(LogLevel.Error, `Result given for '${methodName}' method but server is not expecting a result.`);\r\n            }\r\n        }\r\n    }\r\n    _connectionClosed(error) {\r\n        this._logger.log(LogLevel.Debug, `HubConnection.connectionClosed(${error}) called while in state ${this._connectionState}.`);\r\n        // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\r\n        this._stopDuringStartError = this._stopDuringStartError || error || new AbortError(\"The underlying connection was closed before the hub handshake could complete.\");\r\n        // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\r\n        // If it has already completed, this should just noop.\r\n        if (this._handshakeResolver) {\r\n            this._handshakeResolver();\r\n        }\r\n        this._cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\r\n        this._cleanupTimeout();\r\n        this._cleanupPingTimer();\r\n        if (this._connectionState === HubConnectionState.Disconnecting) {\r\n            this._completeClose(error);\r\n        }\r\n        else if (this._connectionState === HubConnectionState.Connected && this._reconnectPolicy) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._reconnect(error);\r\n        }\r\n        else if (this._connectionState === HubConnectionState.Connected) {\r\n            this._completeClose(error);\r\n        }\r\n        // If none of the above if conditions were true were called the HubConnection must be in either:\r\n        // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\r\n        // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\r\n        //    and potentially continue the reconnect() loop.\r\n        // 3. The Disconnected state in which case we're already done.\r\n    }\r\n    _completeClose(error) {\r\n        if (this._connectionStarted) {\r\n            this._connectionState = HubConnectionState.Disconnected;\r\n            this._connectionStarted = false;\r\n            if (this._messageBuffer) {\r\n                this._messageBuffer._dispose(error !== null && error !== void 0 ? error : new Error(\"Connection closed.\"));\r\n                this._messageBuffer = undefined;\r\n            }\r\n            if (Platform.isBrowser) {\r\n                window.document.removeEventListener(\"freeze\", this._freezeEventListener);\r\n            }\r\n            try {\r\n                this._closedCallbacks.forEach((c) => c.apply(this, [error]));\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Error, `An onclose callback called with error '${error}' threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n    async _reconnect(error) {\r\n        const reconnectStartTime = Date.now();\r\n        let previousReconnectAttempts = 0;\r\n        let retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\r\n        let nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\r\n        if (nextRetryDelay === null) {\r\n            this._logger.log(LogLevel.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\r\n            this._completeClose(error);\r\n            return;\r\n        }\r\n        this._connectionState = HubConnectionState.Reconnecting;\r\n        if (error) {\r\n            this._logger.log(LogLevel.Information, `Connection reconnecting because of error '${error}'.`);\r\n        }\r\n        else {\r\n            this._logger.log(LogLevel.Information, \"Connection reconnecting.\");\r\n        }\r\n        if (this._reconnectingCallbacks.length !== 0) {\r\n            try {\r\n                this._reconnectingCallbacks.forEach((c) => c.apply(this, [error]));\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Error, `An onreconnecting callback called with error '${error}' threw error '${e}'.`);\r\n            }\r\n            // Exit early if an onreconnecting callback called connection.stop().\r\n            if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                this._logger.log(LogLevel.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\r\n                return;\r\n            }\r\n        }\r\n        while (nextRetryDelay !== null) {\r\n            this._logger.log(LogLevel.Information, `Reconnect attempt number ${previousReconnectAttempts} will start in ${nextRetryDelay} ms.`);\r\n            await new Promise((resolve) => {\r\n                this._reconnectDelayHandle = setTimeout(resolve, nextRetryDelay);\r\n            });\r\n            this._reconnectDelayHandle = undefined;\r\n            if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                this._logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\r\n                return;\r\n            }\r\n            try {\r\n                await this._startInternal();\r\n                this._connectionState = HubConnectionState.Connected;\r\n                this._logger.log(LogLevel.Information, \"HubConnection reconnected successfully.\");\r\n                if (this._reconnectedCallbacks.length !== 0) {\r\n                    try {\r\n                        this._reconnectedCallbacks.forEach((c) => c.apply(this, [this.connection.connectionId]));\r\n                    }\r\n                    catch (e) {\r\n                        this._logger.log(LogLevel.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`);\r\n                    }\r\n                }\r\n                return;\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Information, `Reconnect attempt failed because of error '${e}'.`);\r\n                if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                    this._logger.log(LogLevel.Debug, `Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`);\r\n                    // The TypeScript compiler thinks that connectionState must be Connected here. The TypeScript compiler is wrong.\r\n                    if (this._connectionState === HubConnectionState.Disconnecting) {\r\n                        this._completeClose();\r\n                    }\r\n                    return;\r\n                }\r\n                retryError = e instanceof Error ? e : new Error(e.toString());\r\n                nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\r\n            }\r\n        }\r\n        this._logger.log(LogLevel.Information, `Reconnect retries have been exhausted after ${Date.now() - reconnectStartTime} ms and ${previousReconnectAttempts} failed attempts. Connection disconnecting.`);\r\n        this._completeClose();\r\n    }\r\n    _getNextRetryDelay(previousRetryCount, elapsedMilliseconds, retryReason) {\r\n        try {\r\n            return this._reconnectPolicy.nextRetryDelayInMilliseconds({\r\n                elapsedMilliseconds,\r\n                previousRetryCount,\r\n                retryReason,\r\n            });\r\n        }\r\n        catch (e) {\r\n            this._logger.log(LogLevel.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${previousRetryCount}, ${elapsedMilliseconds}) threw error '${e}'.`);\r\n            return null;\r\n        }\r\n    }\r\n    _cancelCallbacksWithError(error) {\r\n        const callbacks = this._callbacks;\r\n        this._callbacks = {};\r\n        Object.keys(callbacks)\r\n            .forEach((key) => {\r\n            const callback = callbacks[key];\r\n            try {\r\n                callback(null, error);\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Error, `Stream 'error' callback called with '${error}' threw error: ${getErrorString(e)}`);\r\n            }\r\n        });\r\n    }\r\n    _cleanupPingTimer() {\r\n        if (this._pingServerHandle) {\r\n            clearTimeout(this._pingServerHandle);\r\n            this._pingServerHandle = undefined;\r\n        }\r\n    }\r\n    _cleanupTimeout() {\r\n        if (this._timeoutHandle) {\r\n            clearTimeout(this._timeoutHandle);\r\n        }\r\n    }\r\n    _createInvocation(methodName, args, nonblocking, streamIds) {\r\n        if (nonblocking) {\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    arguments: args,\r\n                    streamIds,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    arguments: args,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        }\r\n        else {\r\n            const invocationId = this._invocationId;\r\n            this._invocationId++;\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    streamIds,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        }\r\n    }\r\n    _launchStreams(streams, promiseQueue) {\r\n        if (streams.length === 0) {\r\n            return;\r\n        }\r\n        // Synchronize stream data so they arrive in-order on the server\r\n        if (!promiseQueue) {\r\n            promiseQueue = Promise.resolve();\r\n        }\r\n        // We want to iterate over the keys, since the keys are the stream ids\r\n        // eslint-disable-next-line guard-for-in\r\n        for (const streamId in streams) {\r\n            streams[streamId].subscribe({\r\n                complete: () => {\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createCompletionMessage(streamId)));\r\n                },\r\n                error: (err) => {\r\n                    let message;\r\n                    if (err instanceof Error) {\r\n                        message = err.message;\r\n                    }\r\n                    else if (err && err.toString) {\r\n                        message = err.toString();\r\n                    }\r\n                    else {\r\n                        message = \"Unknown error\";\r\n                    }\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createCompletionMessage(streamId, message)));\r\n                },\r\n                next: (item) => {\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createStreamItemMessage(streamId, item)));\r\n                },\r\n            });\r\n        }\r\n    }\r\n    _replaceStreamingParams(args) {\r\n        const streams = [];\r\n        const streamIds = [];\r\n        for (let i = 0; i < args.length; i++) {\r\n            const argument = args[i];\r\n            if (this._isObservable(argument)) {\r\n                const streamId = this._invocationId;\r\n                this._invocationId++;\r\n                // Store the stream for later use\r\n                streams[streamId] = argument;\r\n                streamIds.push(streamId.toString());\r\n                // remove stream from args\r\n                args.splice(i, 1);\r\n            }\r\n        }\r\n        return [streams, streamIds];\r\n    }\r\n    _isObservable(arg) {\r\n        // This allows other stream implementations to just work (like rxjs)\r\n        return arg && arg.subscribe && typeof arg.subscribe === \"function\";\r\n    }\r\n    _createStreamInvocation(methodName, args, streamIds) {\r\n        const invocationId = this._invocationId;\r\n        this._invocationId++;\r\n        if (streamIds.length !== 0) {\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                streamIds,\r\n                target: methodName,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                target: methodName,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        }\r\n    }\r\n    _createCancelInvocation(id) {\r\n        return {\r\n            invocationId: id,\r\n            type: MessageType.CancelInvocation,\r\n        };\r\n    }\r\n    _createStreamItemMessage(id, item) {\r\n        return {\r\n            invocationId: id,\r\n            item,\r\n            type: MessageType.StreamItem,\r\n        };\r\n    }\r\n    _createCompletionMessage(id, error, result) {\r\n        if (error) {\r\n            return {\r\n                error,\r\n                invocationId: id,\r\n                type: MessageType.Completion,\r\n            };\r\n        }\r\n        return {\r\n            invocationId: id,\r\n            result,\r\n            type: MessageType.Completion,\r\n        };\r\n    }\r\n    _createCloseMessage() {\r\n        return { type: MessageType.Close };\r\n    }\r\n}\r\n//# sourceMappingURL=HubConnection.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { DefaultReconnectPolicy } from \"./DefaultReconnectPolicy\";\r\nimport { HttpConnection } from \"./HttpConnection\";\r\nimport { HubConnection } from \"./HubConnection\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { JsonHubProtocol } from \"./JsonHubProtocol\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { Arg, ConsoleLogger } from \"./Utils\";\r\nconst LogLevelNameMapping = {\r\n    trace: LogLevel.Trace,\r\n    debug: LogLevel.Debug,\r\n    info: LogLevel.Information,\r\n    information: LogLevel.Information,\r\n    warn: LogLevel.Warning,\r\n    warning: LogLevel.Warning,\r\n    error: LogLevel.Error,\r\n    critical: LogLevel.Critical,\r\n    none: LogLevel.None,\r\n};\r\nfunction parseLogLevel(name) {\r\n    // Case-insensitive matching via lower-casing\r\n    // Yes, I know case-folding is a complicated problem in Unicode, but we only support\r\n    // the ASCII strings defined in LogLevelNameMapping anyway, so it's fine -anurse.\r\n    const mapping = LogLevelNameMapping[name.toLowerCase()];\r\n    if (typeof mapping !== \"undefined\") {\r\n        return mapping;\r\n    }\r\n    else {\r\n        throw new Error(`Unknown log level: ${name}`);\r\n    }\r\n}\r\n/** A builder for configuring {@link @microsoft/signalr.HubConnection} instances. */\r\nexport class HubConnectionBuilder {\r\n    configureLogging(logging) {\r\n        Arg.isRequired(logging, \"logging\");\r\n        if (isLogger(logging)) {\r\n            this.logger = logging;\r\n        }\r\n        else if (typeof logging === \"string\") {\r\n            const logLevel = parseLogLevel(logging);\r\n            this.logger = new ConsoleLogger(logLevel);\r\n        }\r\n        else {\r\n            this.logger = new ConsoleLogger(logging);\r\n        }\r\n        return this;\r\n    }\r\n    withUrl(url, transportTypeOrOptions) {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isNotEmpty(url, \"url\");\r\n        this.url = url;\r\n        // Flow-typing knows where it's at. Since HttpTransportType is a number and IHttpConnectionOptions is guaranteed\r\n        // to be an object, we know (as does TypeScript) this comparison is all we need to figure out which overload was called.\r\n        if (typeof transportTypeOrOptions === \"object\") {\r\n            this.httpConnectionOptions = { ...this.httpConnectionOptions, ...transportTypeOrOptions };\r\n        }\r\n        else {\r\n            this.httpConnectionOptions = {\r\n                ...this.httpConnectionOptions,\r\n                transport: transportTypeOrOptions,\r\n            };\r\n        }\r\n        return this;\r\n    }\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified Hub Protocol.\r\n     *\r\n     * @param {IHubProtocol} protocol The {@link @microsoft/signalr.IHubProtocol} implementation to use.\r\n     */\r\n    withHubProtocol(protocol) {\r\n        Arg.isRequired(protocol, \"protocol\");\r\n        this.protocol = protocol;\r\n        return this;\r\n    }\r\n    withAutomaticReconnect(retryDelaysOrReconnectPolicy) {\r\n        if (this.reconnectPolicy) {\r\n            throw new Error(\"A reconnectPolicy has already been set.\");\r\n        }\r\n        if (!retryDelaysOrReconnectPolicy) {\r\n            this.reconnectPolicy = new DefaultReconnectPolicy();\r\n        }\r\n        else if (Array.isArray(retryDelaysOrReconnectPolicy)) {\r\n            this.reconnectPolicy = new DefaultReconnectPolicy(retryDelaysOrReconnectPolicy);\r\n        }\r\n        else {\r\n            this.reconnectPolicy = retryDelaysOrReconnectPolicy;\r\n        }\r\n        return this;\r\n    }\r\n    /** Configures {@link @microsoft/signalr.HubConnection.serverTimeoutInMilliseconds} for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    withServerTimeout(milliseconds) {\r\n        Arg.isRequired(milliseconds, \"milliseconds\");\r\n        this._serverTimeoutInMilliseconds = milliseconds;\r\n        return this;\r\n    }\r\n    /** Configures {@link @microsoft/signalr.HubConnection.keepAliveIntervalInMilliseconds} for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    withKeepAliveInterval(milliseconds) {\r\n        Arg.isRequired(milliseconds, \"milliseconds\");\r\n        this._keepAliveIntervalInMilliseconds = milliseconds;\r\n        return this;\r\n    }\r\n    /** Enables and configures options for the Stateful Reconnect feature.\r\n     *\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    withStatefulReconnect(options) {\r\n        if (this.httpConnectionOptions === undefined) {\r\n            this.httpConnectionOptions = {};\r\n        }\r\n        this.httpConnectionOptions._useStatefulReconnect = true;\r\n        this._statefulReconnectBufferSize = options === null || options === void 0 ? void 0 : options.bufferSize;\r\n        return this;\r\n    }\r\n    /** Creates a {@link @microsoft/signalr.HubConnection} from the configuration options specified in this builder.\r\n     *\r\n     * @returns {HubConnection} The configured {@link @microsoft/signalr.HubConnection}.\r\n     */\r\n    build() {\r\n        // If httpConnectionOptions has a logger, use it. Otherwise, override it with the one\r\n        // provided to configureLogger\r\n        const httpConnectionOptions = this.httpConnectionOptions || {};\r\n        // If it's 'null', the user **explicitly** asked for null, don't mess with it.\r\n        if (httpConnectionOptions.logger === undefined) {\r\n            // If our logger is undefined or null, that's OK, the HttpConnection constructor will handle it.\r\n            httpConnectionOptions.logger = this.logger;\r\n        }\r\n        // Now create the connection\r\n        if (!this.url) {\r\n            throw new Error(\"The 'HubConnectionBuilder.withUrl' method must be called before building the connection.\");\r\n        }\r\n        const connection = new HttpConnection(this.url, httpConnectionOptions);\r\n        return HubConnection.create(connection, this.logger || NullLogger.instance, this.protocol || new JsonHubProtocol(), this.reconnectPolicy, this._serverTimeoutInMilliseconds, this._keepAliveIntervalInMilliseconds, this._statefulReconnectBufferSize);\r\n    }\r\n}\r\nfunction isLogger(logger) {\r\n    return logger.log !== undefined;\r\n}\r\n//# sourceMappingURL=HubConnectionBuilder.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n/** Defines the type of a Hub Message. */\r\nexport var MessageType;\r\n(function (MessageType) {\r\n    /** Indicates the message is an Invocation message and implements the {@link @microsoft/signalr.InvocationMessage} interface. */\r\n    MessageType[MessageType[\"Invocation\"] = 1] = \"Invocation\";\r\n    /** Indicates the message is a StreamItem message and implements the {@link @microsoft/signalr.StreamItemMessage} interface. */\r\n    MessageType[MessageType[\"StreamItem\"] = 2] = \"StreamItem\";\r\n    /** Indicates the message is a Completion message and implements the {@link @microsoft/signalr.CompletionMessage} interface. */\r\n    MessageType[MessageType[\"Completion\"] = 3] = \"Completion\";\r\n    /** Indicates the message is a Stream Invocation message and implements the {@link @microsoft/signalr.StreamInvocationMessage} interface. */\r\n    MessageType[MessageType[\"StreamInvocation\"] = 4] = \"StreamInvocation\";\r\n    /** Indicates the message is a Cancel Invocation message and implements the {@link @microsoft/signalr.CancelInvocationMessage} interface. */\r\n    MessageType[MessageType[\"CancelInvocation\"] = 5] = \"CancelInvocation\";\r\n    /** Indicates the message is a Ping message and implements the {@link @microsoft/signalr.PingMessage} interface. */\r\n    MessageType[MessageType[\"Ping\"] = 6] = \"Ping\";\r\n    /** Indicates the message is a Close message and implements the {@link @microsoft/signalr.CloseMessage} interface. */\r\n    MessageType[MessageType[\"Close\"] = 7] = \"Close\";\r\n    MessageType[MessageType[\"Ack\"] = 8] = \"Ack\";\r\n    MessageType[MessageType[\"Sequence\"] = 9] = \"Sequence\";\r\n})(MessageType || (MessageType = {}));\r\n//# sourceMappingURL=IHubProtocol.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n// These values are designed to match the ASP.NET Log Levels since that's the pattern we're emulating here.\r\n/** Indicates the severity of a log message.\r\n *\r\n * Log Levels are ordered in increasing severity. So `Debug` is more severe than `Trace`, etc.\r\n */\r\nexport var LogLevel;\r\n(function (LogLevel) {\r\n    /** Log level for very low severity diagnostic messages. */\r\n    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\r\n    /** Log level for low severity diagnostic messages. */\r\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\r\n    /** Log level for informational diagnostic messages. */\r\n    LogLevel[LogLevel[\"Information\"] = 2] = \"Information\";\r\n    /** Log level for diagnostic messages that indicate a non-fatal problem. */\r\n    LogLevel[LogLevel[\"Warning\"] = 3] = \"Warning\";\r\n    /** Log level for diagnostic messages that indicate a failure in the current operation. */\r\n    LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\r\n    /** Log level for diagnostic messages that indicate a failure that will terminate the entire application. */\r\n    LogLevel[LogLevel[\"Critical\"] = 5] = \"Critical\";\r\n    /** The highest possible log level. Used when configuring logging to indicate that no log messages should be emitted. */\r\n    LogLevel[LogLevel[\"None\"] = 6] = \"None\";\r\n})(LogLevel || (LogLevel = {}));\r\n//# sourceMappingURL=ILogger.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n// This will be treated as a bit flag in the future, so we keep it using power-of-two values.\r\n/** Specifies a specific HTTP transport type. */\r\nexport var HttpTransportType;\r\n(function (HttpTransportType) {\r\n    /** Specifies no transport preference. */\r\n    HttpTransportType[HttpTransportType[\"None\"] = 0] = \"None\";\r\n    /** Specifies the WebSockets transport. */\r\n    HttpTransportType[HttpTransportType[\"WebSockets\"] = 1] = \"WebSockets\";\r\n    /** Specifies the Server-Sent Events transport. */\r\n    HttpTransportType[HttpTransportType[\"ServerSentEvents\"] = 2] = \"ServerSentEvents\";\r\n    /** Specifies the Long Polling transport. */\r\n    HttpTransportType[HttpTransportType[\"LongPolling\"] = 4] = \"LongPolling\";\r\n})(HttpTransportType || (HttpTransportType = {}));\r\n/** Specifies the transfer format for a connection. */\r\nexport var TransferFormat;\r\n(function (TransferFormat) {\r\n    /** Specifies that only text data will be transmitted over the connection. */\r\n    TransferFormat[TransferFormat[\"Text\"] = 1] = \"Text\";\r\n    /** Specifies that binary data will be transmitted over the connection. */\r\n    TransferFormat[TransferFormat[\"Binary\"] = 2] = \"Binary\";\r\n})(TransferFormat || (TransferFormat = {}));\r\n//# sourceMappingURL=ITransport.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { MessageType } from \"./IHubProtocol\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { TextMessageFormat } from \"./TextMessageFormat\";\r\nconst JSON_HUB_PROTOCOL_NAME = \"json\";\r\n/** Implements the JSON Hub Protocol. */\r\nexport class JsonHubProtocol {\r\n    constructor() {\r\n        /** @inheritDoc */\r\n        this.name = JSON_HUB_PROTOCOL_NAME;\r\n        /** @inheritDoc */\r\n        this.version = 2;\r\n        /** @inheritDoc */\r\n        this.transferFormat = TransferFormat.Text;\r\n    }\r\n    /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.\r\n     *\r\n     * @param {string} input A string containing the serialized representation.\r\n     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n     */\r\n    parseMessages(input, logger) {\r\n        // The interface does allow \"ArrayBuffer\" to be passed in, but this implementation does not. So let's throw a useful error.\r\n        if (typeof input !== \"string\") {\r\n            throw new Error(\"Invalid input for JSON hub protocol. Expected a string.\");\r\n        }\r\n        if (!input) {\r\n            return [];\r\n        }\r\n        if (logger === null) {\r\n            logger = NullLogger.instance;\r\n        }\r\n        // Parse the messages\r\n        const messages = TextMessageFormat.parse(input);\r\n        const hubMessages = [];\r\n        for (const message of messages) {\r\n            const parsedMessage = JSON.parse(message);\r\n            if (typeof parsedMessage.type !== \"number\") {\r\n                throw new Error(\"Invalid payload.\");\r\n            }\r\n            switch (parsedMessage.type) {\r\n                case MessageType.Invocation:\r\n                    this._isInvocationMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.StreamItem:\r\n                    this._isStreamItemMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Completion:\r\n                    this._isCompletionMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Ping:\r\n                    // Single value, no need to validate\r\n                    break;\r\n                case MessageType.Close:\r\n                    // All optional values, no need to validate\r\n                    break;\r\n                case MessageType.Ack:\r\n                    this._isAckMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Sequence:\r\n                    this._isSequenceMessage(parsedMessage);\r\n                    break;\r\n                default:\r\n                    // Future protocol changes can add message types, old clients can ignore them\r\n                    logger.log(LogLevel.Information, \"Unknown message type '\" + parsedMessage.type + \"' ignored.\");\r\n                    continue;\r\n            }\r\n            hubMessages.push(parsedMessage);\r\n        }\r\n        return hubMessages;\r\n    }\r\n    /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string and returns it.\r\n     *\r\n     * @param {HubMessage} message The message to write.\r\n     * @returns {string} A string containing the serialized representation of the message.\r\n     */\r\n    writeMessage(message) {\r\n        return TextMessageFormat.write(JSON.stringify(message));\r\n    }\r\n    _isInvocationMessage(message) {\r\n        this._assertNotEmptyString(message.target, \"Invalid payload for Invocation message.\");\r\n        if (message.invocationId !== undefined) {\r\n            this._assertNotEmptyString(message.invocationId, \"Invalid payload for Invocation message.\");\r\n        }\r\n    }\r\n    _isStreamItemMessage(message) {\r\n        this._assertNotEmptyString(message.invocationId, \"Invalid payload for StreamItem message.\");\r\n        if (message.item === undefined) {\r\n            throw new Error(\"Invalid payload for StreamItem message.\");\r\n        }\r\n    }\r\n    _isCompletionMessage(message) {\r\n        if (message.result && message.error) {\r\n            throw new Error(\"Invalid payload for Completion message.\");\r\n        }\r\n        if (!message.result && message.error) {\r\n            this._assertNotEmptyString(message.error, \"Invalid payload for Completion message.\");\r\n        }\r\n        this._assertNotEmptyString(message.invocationId, \"Invalid payload for Completion message.\");\r\n    }\r\n    _isAckMessage(message) {\r\n        if (typeof message.sequenceId !== 'number') {\r\n            throw new Error(\"Invalid SequenceId for Ack message.\");\r\n        }\r\n    }\r\n    _isSequenceMessage(message) {\r\n        if (typeof message.sequenceId !== 'number') {\r\n            throw new Error(\"Invalid SequenceId for Sequence message.\");\r\n        }\r\n    }\r\n    _assertNotEmptyString(value, errorMessage) {\r\n        if (typeof value !== \"string\" || value === \"\") {\r\n            throw new Error(errorMessage);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=JsonHubProtocol.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n/** A logger that does nothing when log messages are sent to it. */\r\nexport class NullLogger {\r\n    constructor() { }\r\n    /** @inheritDoc */\r\n    // eslint-disable-next-line\r\n    log(_logLevel, _message) {\r\n    }\r\n}\r\n/** The singleton instance of the {@link @microsoft/signalr.NullLogger}. */\r\nNullLogger.instance = new NullLogger();\r\n//# sourceMappingURL=Loggers.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { AbortController } from \"./AbortController\";\r\nimport { HttpError, TimeoutError } from \"./Errors\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, sendMessage } from \"./Utils\";\r\n// Not exported from 'index', this type is internal.\r\n/** @private */\r\nexport class LongPollingTransport {\r\n    // This is an internal type, not exported from 'index' so this is really just internal.\r\n    get pollAborted() {\r\n        return this._pollAbort.aborted;\r\n    }\r\n    constructor(httpClient, logger, options) {\r\n        this._httpClient = httpClient;\r\n        this._logger = logger;\r\n        this._pollAbort = new AbortController();\r\n        this._options = options;\r\n        this._running = false;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n    async connect(url, transferFormat) {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._url = url;\r\n        this._logger.log(LogLevel.Trace, \"(LongPolling transport) Connecting.\");\r\n        // Allow binary format on Node and Browsers that support binary content (indicated by the presence of responseType property)\r\n        if (transferFormat === TransferFormat.Binary &&\r\n            (typeof XMLHttpRequest !== \"undefined\" && typeof new XMLHttpRequest().responseType !== \"string\")) {\r\n            throw new Error(\"Binary protocols over XmlHttpRequest not implementing advanced features are not supported.\");\r\n        }\r\n        const [name, value] = getUserAgentHeader();\r\n        const headers = { [name]: value, ...this._options.headers };\r\n        const pollOptions = {\r\n            abortSignal: this._pollAbort.signal,\r\n            headers,\r\n            timeout: 100000,\r\n            withCredentials: this._options.withCredentials,\r\n        };\r\n        if (transferFormat === TransferFormat.Binary) {\r\n            pollOptions.responseType = \"arraybuffer\";\r\n        }\r\n        // Make initial long polling request\r\n        // Server uses first long polling request to finish initializing connection and it returns without data\r\n        const pollUrl = `${url}&_=${Date.now()}`;\r\n        this._logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);\r\n        const response = await this._httpClient.get(pollUrl, pollOptions);\r\n        if (response.statusCode !== 200) {\r\n            this._logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);\r\n            // Mark running as false so that the poll immediately ends and runs the close logic\r\n            this._closeError = new HttpError(response.statusText || \"\", response.statusCode);\r\n            this._running = false;\r\n        }\r\n        else {\r\n            this._running = true;\r\n        }\r\n        this._receiving = this._poll(this._url, pollOptions);\r\n    }\r\n    async _poll(url, pollOptions) {\r\n        try {\r\n            while (this._running) {\r\n                try {\r\n                    const pollUrl = `${url}&_=${Date.now()}`;\r\n                    this._logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);\r\n                    const response = await this._httpClient.get(pollUrl, pollOptions);\r\n                    if (response.statusCode === 204) {\r\n                        this._logger.log(LogLevel.Information, \"(LongPolling transport) Poll terminated by server.\");\r\n                        this._running = false;\r\n                    }\r\n                    else if (response.statusCode !== 200) {\r\n                        this._logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);\r\n                        // Unexpected status code\r\n                        this._closeError = new HttpError(response.statusText || \"\", response.statusCode);\r\n                        this._running = false;\r\n                    }\r\n                    else {\r\n                        // Process the response\r\n                        if (response.content) {\r\n                            this._logger.log(LogLevel.Trace, `(LongPolling transport) data received. ${getDataDetail(response.content, this._options.logMessageContent)}.`);\r\n                            if (this.onreceive) {\r\n                                this.onreceive(response.content);\r\n                            }\r\n                        }\r\n                        else {\r\n                            // This is another way timeout manifest.\r\n                            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n                        }\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    if (!this._running) {\r\n                        // Log but disregard errors that occur after stopping\r\n                        this._logger.log(LogLevel.Trace, `(LongPolling transport) Poll errored after shutdown: ${e.message}`);\r\n                    }\r\n                    else {\r\n                        if (e instanceof TimeoutError) {\r\n                            // Ignore timeouts and reissue the poll.\r\n                            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n                        }\r\n                        else {\r\n                            // Close the connection with the error as the result.\r\n                            this._closeError = e;\r\n                            this._running = false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        finally {\r\n            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Polling complete.\");\r\n            // We will reach here with pollAborted==false when the server returned a response causing the transport to stop.\r\n            // If pollAborted==true then client initiated the stop and the stop method will raise the close event after DELETE is sent.\r\n            if (!this.pollAborted) {\r\n                this._raiseOnClose();\r\n            }\r\n        }\r\n    }\r\n    async send(data) {\r\n        if (!this._running) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this._logger, \"LongPolling\", this._httpClient, this._url, data, this._options);\r\n    }\r\n    async stop() {\r\n        this._logger.log(LogLevel.Trace, \"(LongPolling transport) Stopping polling.\");\r\n        // Tell receiving loop to stop, abort any current request, and then wait for it to finish\r\n        this._running = false;\r\n        this._pollAbort.abort();\r\n        try {\r\n            await this._receiving;\r\n            // Send DELETE to clean up long polling on the server\r\n            this._logger.log(LogLevel.Trace, `(LongPolling transport) sending DELETE request to ${this._url}.`);\r\n            const headers = {};\r\n            const [name, value] = getUserAgentHeader();\r\n            headers[name] = value;\r\n            const deleteOptions = {\r\n                headers: { ...headers, ...this._options.headers },\r\n                timeout: this._options.timeout,\r\n                withCredentials: this._options.withCredentials,\r\n            };\r\n            let error;\r\n            try {\r\n                await this._httpClient.delete(this._url, deleteOptions);\r\n            }\r\n            catch (err) {\r\n                error = err;\r\n            }\r\n            if (error) {\r\n                if (error instanceof HttpError) {\r\n                    if (error.statusCode === 404) {\r\n                        this._logger.log(LogLevel.Trace, \"(LongPolling transport) A 404 response was returned from sending a DELETE request.\");\r\n                    }\r\n                    else {\r\n                        this._logger.log(LogLevel.Trace, `(LongPolling transport) Error sending a DELETE request: ${error}`);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                this._logger.log(LogLevel.Trace, \"(LongPolling transport) DELETE request accepted.\");\r\n            }\r\n        }\r\n        finally {\r\n            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Stop finished.\");\r\n            // Raise close event here instead of in polling\r\n            // It needs to happen after the DELETE request is sent\r\n            this._raiseOnClose();\r\n        }\r\n    }\r\n    _raiseOnClose() {\r\n        if (this.onclose) {\r\n            let logMessage = \"(LongPolling transport) Firing onclose event.\";\r\n            if (this._closeError) {\r\n                logMessage += \" Error: \" + this._closeError;\r\n            }\r\n            this._logger.log(LogLevel.Trace, logMessage);\r\n            this.onclose(this._closeError);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=LongPollingTransport.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { MessageType } from \"./IHubProtocol\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n/** @private */\r\nexport class MessageBuffer {\r\n    constructor(protocol, connection, bufferSize) {\r\n        this._bufferSize = 100000;\r\n        this._messages = [];\r\n        this._totalMessageCount = 0;\r\n        this._waitForSequenceMessage = false;\r\n        // Message IDs start at 1 and always increment by 1\r\n        this._nextReceivingSequenceId = 1;\r\n        this._latestReceivedSequenceId = 0;\r\n        this._bufferedByteCount = 0;\r\n        this._reconnectInProgress = false;\r\n        this._protocol = protocol;\r\n        this._connection = connection;\r\n        this._bufferSize = bufferSize;\r\n    }\r\n    async _send(message) {\r\n        const serializedMessage = this._protocol.writeMessage(message);\r\n        let backpressurePromise = Promise.resolve();\r\n        // Only count invocation messages. Acks, pings, etc. don't need to be resent on reconnect\r\n        if (this._isInvocationMessage(message)) {\r\n            this._totalMessageCount++;\r\n            let backpressurePromiseResolver = () => { };\r\n            let backpressurePromiseRejector = () => { };\r\n            if (isArrayBuffer(serializedMessage)) {\r\n                this._bufferedByteCount += serializedMessage.byteLength;\r\n            }\r\n            else {\r\n                this._bufferedByteCount += serializedMessage.length;\r\n            }\r\n            if (this._bufferedByteCount >= this._bufferSize) {\r\n                backpressurePromise = new Promise((resolve, reject) => {\r\n                    backpressurePromiseResolver = resolve;\r\n                    backpressurePromiseRejector = reject;\r\n                });\r\n            }\r\n            this._messages.push(new BufferedItem(serializedMessage, this._totalMessageCount, backpressurePromiseResolver, backpressurePromiseRejector));\r\n        }\r\n        try {\r\n            // If this is set it means we are reconnecting or resending\r\n            // We don't want to send on a disconnected connection\r\n            // And we don't want to send if resend is running since that would mean sending\r\n            // this message twice\r\n            if (!this._reconnectInProgress) {\r\n                await this._connection.send(serializedMessage);\r\n            }\r\n        }\r\n        catch {\r\n            this._disconnected();\r\n        }\r\n        await backpressurePromise;\r\n    }\r\n    _ack(ackMessage) {\r\n        let newestAckedMessage = -1;\r\n        // Find index of newest message being acked\r\n        for (let index = 0; index < this._messages.length; index++) {\r\n            const element = this._messages[index];\r\n            if (element._id <= ackMessage.sequenceId) {\r\n                newestAckedMessage = index;\r\n                if (isArrayBuffer(element._message)) {\r\n                    this._bufferedByteCount -= element._message.byteLength;\r\n                }\r\n                else {\r\n                    this._bufferedByteCount -= element._message.length;\r\n                }\r\n                // resolve items that have already been sent and acked\r\n                element._resolver();\r\n            }\r\n            else if (this._bufferedByteCount < this._bufferSize) {\r\n                // resolve items that now fall under the buffer limit but haven't been acked\r\n                element._resolver();\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        if (newestAckedMessage !== -1) {\r\n            // We're removing everything including the message pointed to, so add 1\r\n            this._messages = this._messages.slice(newestAckedMessage + 1);\r\n        }\r\n    }\r\n    _shouldProcessMessage(message) {\r\n        if (this._waitForSequenceMessage) {\r\n            if (message.type !== MessageType.Sequence) {\r\n                return false;\r\n            }\r\n            else {\r\n                this._waitForSequenceMessage = false;\r\n                return true;\r\n            }\r\n        }\r\n        // No special processing for acks, pings, etc.\r\n        if (!this._isInvocationMessage(message)) {\r\n            return true;\r\n        }\r\n        const currentId = this._nextReceivingSequenceId;\r\n        this._nextReceivingSequenceId++;\r\n        if (currentId <= this._latestReceivedSequenceId) {\r\n            if (currentId === this._latestReceivedSequenceId) {\r\n                // Should only hit this if we just reconnected and the server is sending\r\n                // Messages it has buffered, which would mean it hasn't seen an Ack for these messages\r\n                this._ackTimer();\r\n            }\r\n            // Ignore, this is a duplicate message\r\n            return false;\r\n        }\r\n        this._latestReceivedSequenceId = currentId;\r\n        // Only start the timer for sending an Ack message when we have a message to ack. This also conveniently solves\r\n        // timer throttling by not having a recursive timer, and by starting the timer via a network call (recv)\r\n        this._ackTimer();\r\n        return true;\r\n    }\r\n    _resetSequence(message) {\r\n        if (message.sequenceId > this._nextReceivingSequenceId) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._connection.stop(new Error(\"Sequence ID greater than amount of messages we've received.\"));\r\n            return;\r\n        }\r\n        this._nextReceivingSequenceId = message.sequenceId;\r\n    }\r\n    _disconnected() {\r\n        this._reconnectInProgress = true;\r\n        this._waitForSequenceMessage = true;\r\n    }\r\n    async _resend() {\r\n        const sequenceId = this._messages.length !== 0\r\n            ? this._messages[0]._id\r\n            : this._totalMessageCount + 1;\r\n        await this._connection.send(this._protocol.writeMessage({ type: MessageType.Sequence, sequenceId }));\r\n        // Get a local variable to the _messages, just in case messages are acked while resending\r\n        // Which would slice the _messages array (which creates a new copy)\r\n        const messages = this._messages;\r\n        for (const element of messages) {\r\n            await this._connection.send(element._message);\r\n        }\r\n        this._reconnectInProgress = false;\r\n    }\r\n    _dispose(error) {\r\n        error !== null && error !== void 0 ? error : (error = new Error(\"Unable to reconnect to server.\"));\r\n        // Unblock backpressure if any\r\n        for (const element of this._messages) {\r\n            element._rejector(error);\r\n        }\r\n    }\r\n    _isInvocationMessage(message) {\r\n        // There is no way to check if something implements an interface.\r\n        // So we individually check the messages in a switch statement.\r\n        // To make sure we don't miss any message types we rely on the compiler\r\n        // seeing the function returns a value and it will do the\r\n        // exhaustive check for us on the switch statement, since we don't use 'case default'\r\n        switch (message.type) {\r\n            case MessageType.Invocation:\r\n            case MessageType.StreamItem:\r\n            case MessageType.Completion:\r\n            case MessageType.StreamInvocation:\r\n            case MessageType.CancelInvocation:\r\n                return true;\r\n            case MessageType.Close:\r\n            case MessageType.Sequence:\r\n            case MessageType.Ping:\r\n            case MessageType.Ack:\r\n                return false;\r\n        }\r\n    }\r\n    _ackTimer() {\r\n        if (this._ackTimerHandle === undefined) {\r\n            this._ackTimerHandle = setTimeout(async () => {\r\n                try {\r\n                    if (!this._reconnectInProgress) {\r\n                        await this._connection.send(this._protocol.writeMessage({ type: MessageType.Ack, sequenceId: this._latestReceivedSequenceId }));\r\n                    }\r\n                    // Ignore errors, that means the connection is closed and we don't care about the Ack message anymore.\r\n                }\r\n                catch { }\r\n                clearTimeout(this._ackTimerHandle);\r\n                this._ackTimerHandle = undefined;\r\n                // 1 second delay so we don't spam Ack messages if there are many messages being received at once.\r\n            }, 1000);\r\n        }\r\n    }\r\n}\r\nclass BufferedItem {\r\n    constructor(message, id, resolver, rejector) {\r\n        this._message = message;\r\n        this._id = id;\r\n        this._resolver = resolver;\r\n        this._rejector = rejector;\r\n    }\r\n}\r\n//# sourceMappingURL=MessageBuffer.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform, sendMessage } from \"./Utils\";\r\n/** @private */\r\nexport class ServerSentEventsTransport {\r\n    constructor(httpClient, accessToken, logger, options) {\r\n        this._httpClient = httpClient;\r\n        this._accessToken = accessToken;\r\n        this._logger = logger;\r\n        this._options = options;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n    async connect(url, transferFormat) {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\");\r\n        // set url before accessTokenFactory because this._url is only for send and we set the auth header instead of the query string for send\r\n        this._url = url;\r\n        if (this._accessToken) {\r\n            url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(this._accessToken)}`;\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            let opened = false;\r\n            if (transferFormat !== TransferFormat.Text) {\r\n                reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\r\n                return;\r\n            }\r\n            let eventSource;\r\n            if (Platform.isBrowser || Platform.isWebWorker) {\r\n                eventSource = new this._options.EventSource(url, { withCredentials: this._options.withCredentials });\r\n            }\r\n            else {\r\n                // Non-browser passes cookies via the dictionary\r\n                const cookies = this._httpClient.getCookieString(url);\r\n                const headers = {};\r\n                headers.Cookie = cookies;\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n                eventSource = new this._options.EventSource(url, { withCredentials: this._options.withCredentials, headers: { ...headers, ...this._options.headers } });\r\n            }\r\n            try {\r\n                eventSource.onmessage = (e) => {\r\n                    if (this.onreceive) {\r\n                        try {\r\n                            this._logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, this._options.logMessageContent)}.`);\r\n                            this.onreceive(e.data);\r\n                        }\r\n                        catch (error) {\r\n                            this._close(error);\r\n                            return;\r\n                        }\r\n                    }\r\n                };\r\n                // @ts-ignore: not using event on purpose\r\n                eventSource.onerror = (e) => {\r\n                    // EventSource doesn't give any useful information about server side closes.\r\n                    if (opened) {\r\n                        this._close();\r\n                    }\r\n                    else {\r\n                        reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\"\r\n                            + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\"\r\n                            + \" If you have multiple servers check that sticky sessions are enabled.\"));\r\n                    }\r\n                };\r\n                eventSource.onopen = () => {\r\n                    this._logger.log(LogLevel.Information, `SSE connected to ${this._url}`);\r\n                    this._eventSource = eventSource;\r\n                    opened = true;\r\n                    resolve();\r\n                };\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n                return;\r\n            }\r\n        });\r\n    }\r\n    async send(data) {\r\n        if (!this._eventSource) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this._logger, \"SSE\", this._httpClient, this._url, data, this._options);\r\n    }\r\n    stop() {\r\n        this._close();\r\n        return Promise.resolve();\r\n    }\r\n    _close(e) {\r\n        if (this._eventSource) {\r\n            this._eventSource.close();\r\n            this._eventSource = undefined;\r\n            if (this.onclose) {\r\n                this.onclose(e);\r\n            }\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=ServerSentEventsTransport.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { SubjectSubscription } from \"./Utils\";\r\n/** Stream implementation to stream items to the server. */\r\nexport class Subject {\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n    next(item) {\r\n        for (const observer of this.observers) {\r\n            observer.next(item);\r\n        }\r\n    }\r\n    error(err) {\r\n        for (const observer of this.observers) {\r\n            if (observer.error) {\r\n                observer.error(err);\r\n            }\r\n        }\r\n    }\r\n    complete() {\r\n        for (const observer of this.observers) {\r\n            if (observer.complete) {\r\n                observer.complete();\r\n            }\r\n        }\r\n    }\r\n    subscribe(observer) {\r\n        this.observers.push(observer);\r\n        return new SubjectSubscription(this, observer);\r\n    }\r\n}\r\n//# sourceMappingURL=Subject.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n// Not exported from index\r\n/** @private */\r\nexport class TextMessageFormat {\r\n    static write(output) {\r\n        return `${output}${TextMessageFormat.RecordSeparator}`;\r\n    }\r\n    static parse(input) {\r\n        if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {\r\n            throw new Error(\"Message is incomplete.\");\r\n        }\r\n        const messages = input.split(TextMessageFormat.RecordSeparator);\r\n        messages.pop();\r\n        return messages;\r\n    }\r\n}\r\nTextMessageFormat.RecordSeparatorCode = 0x1e;\r\nTextMessageFormat.RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);\r\n//# sourceMappingURL=TextMessageFormat.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { NullLogger } from \"./Loggers\";\r\n// Version token that will be replaced by the prepack command\r\n/** The version of the SignalR client. */\r\nexport const VERSION = \"8.0.0\";\r\n/** @private */\r\nexport class Arg {\r\n    static isRequired(val, name) {\r\n        if (val === null || val === undefined) {\r\n            throw new Error(`The '${name}' argument is required.`);\r\n        }\r\n    }\r\n    static isNotEmpty(val, name) {\r\n        if (!val || val.match(/^\\s*$/)) {\r\n            throw new Error(`The '${name}' argument should not be empty.`);\r\n        }\r\n    }\r\n    static isIn(val, values, name) {\r\n        // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.\r\n        if (!(val in values)) {\r\n            throw new Error(`Unknown ${name} value: ${val}.`);\r\n        }\r\n    }\r\n}\r\n/** @private */\r\nexport class Platform {\r\n    // react-native has a window but no document so we should check both\r\n    static get isBrowser() {\r\n        return !Platform.isNode && typeof window === \"object\" && typeof window.document === \"object\";\r\n    }\r\n    // WebWorkers don't have a window object so the isBrowser check would fail\r\n    static get isWebWorker() {\r\n        return !Platform.isNode && typeof self === \"object\" && \"importScripts\" in self;\r\n    }\r\n    // react-native has a window but no document\r\n    static get isReactNative() {\r\n        return !Platform.isNode && typeof window === \"object\" && typeof window.document === \"undefined\";\r\n    }\r\n    // Node apps shouldn't have a window object, but WebWorkers don't either\r\n    // so we need to check for both WebWorker and window\r\n    static get isNode() {\r\n        return typeof process !== \"undefined\" && process.release && process.release.name === \"node\";\r\n    }\r\n}\r\n/** @private */\r\nexport function getDataDetail(data, includeContent) {\r\n    let detail = \"\";\r\n    if (isArrayBuffer(data)) {\r\n        detail = `Binary data of length ${data.byteLength}`;\r\n        if (includeContent) {\r\n            detail += `. Content: '${formatArrayBuffer(data)}'`;\r\n        }\r\n    }\r\n    else if (typeof data === \"string\") {\r\n        detail = `String data of length ${data.length}`;\r\n        if (includeContent) {\r\n            detail += `. Content: '${data}'`;\r\n        }\r\n    }\r\n    return detail;\r\n}\r\n/** @private */\r\nexport function formatArrayBuffer(data) {\r\n    const view = new Uint8Array(data);\r\n    // Uint8Array.map only supports returning another Uint8Array?\r\n    let str = \"\";\r\n    view.forEach((num) => {\r\n        const pad = num < 16 ? \"0\" : \"\";\r\n        str += `0x${pad}${num.toString(16)} `;\r\n    });\r\n    // Trim of trailing space.\r\n    return str.substr(0, str.length - 1);\r\n}\r\n// Also in signalr-protocol-msgpack/Utils.ts\r\n/** @private */\r\nexport function isArrayBuffer(val) {\r\n    return val && typeof ArrayBuffer !== \"undefined\" &&\r\n        (val instanceof ArrayBuffer ||\r\n            // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\r\n            (val.constructor && val.constructor.name === \"ArrayBuffer\"));\r\n}\r\n/** @private */\r\nexport async function sendMessage(logger, transportName, httpClient, url, content, options) {\r\n    const headers = {};\r\n    const [name, value] = getUserAgentHeader();\r\n    headers[name] = value;\r\n    logger.log(LogLevel.Trace, `(${transportName} transport) sending data. ${getDataDetail(content, options.logMessageContent)}.`);\r\n    const responseType = isArrayBuffer(content) ? \"arraybuffer\" : \"text\";\r\n    const response = await httpClient.post(url, {\r\n        content,\r\n        headers: { ...headers, ...options.headers },\r\n        responseType,\r\n        timeout: options.timeout,\r\n        withCredentials: options.withCredentials,\r\n    });\r\n    logger.log(LogLevel.Trace, `(${transportName} transport) request complete. Response status: ${response.statusCode}.`);\r\n}\r\n/** @private */\r\nexport function createLogger(logger) {\r\n    if (logger === undefined) {\r\n        return new ConsoleLogger(LogLevel.Information);\r\n    }\r\n    if (logger === null) {\r\n        return NullLogger.instance;\r\n    }\r\n    if (logger.log !== undefined) {\r\n        return logger;\r\n    }\r\n    return new ConsoleLogger(logger);\r\n}\r\n/** @private */\r\nexport class SubjectSubscription {\r\n    constructor(subject, observer) {\r\n        this._subject = subject;\r\n        this._observer = observer;\r\n    }\r\n    dispose() {\r\n        const index = this._subject.observers.indexOf(this._observer);\r\n        if (index > -1) {\r\n            this._subject.observers.splice(index, 1);\r\n        }\r\n        if (this._subject.observers.length === 0 && this._subject.cancelCallback) {\r\n            this._subject.cancelCallback().catch((_) => { });\r\n        }\r\n    }\r\n}\r\n/** @private */\r\nexport class ConsoleLogger {\r\n    constructor(minimumLogLevel) {\r\n        this._minLevel = minimumLogLevel;\r\n        this.out = console;\r\n    }\r\n    log(logLevel, message) {\r\n        if (logLevel >= this._minLevel) {\r\n            const msg = `[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`;\r\n            switch (logLevel) {\r\n                case LogLevel.Critical:\r\n                case LogLevel.Error:\r\n                    this.out.error(msg);\r\n                    break;\r\n                case LogLevel.Warning:\r\n                    this.out.warn(msg);\r\n                    break;\r\n                case LogLevel.Information:\r\n                    this.out.info(msg);\r\n                    break;\r\n                default:\r\n                    // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug\r\n                    this.out.log(msg);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n/** @private */\r\nexport function getUserAgentHeader() {\r\n    let userAgentHeaderName = \"X-SignalR-User-Agent\";\r\n    if (Platform.isNode) {\r\n        userAgentHeaderName = \"User-Agent\";\r\n    }\r\n    return [userAgentHeaderName, constructUserAgent(VERSION, getOsName(), getRuntime(), getRuntimeVersion())];\r\n}\r\n/** @private */\r\nexport function constructUserAgent(version, os, runtime, runtimeVersion) {\r\n    // Microsoft SignalR/[Version] ([Detailed Version]; [Operating System]; [Runtime]; [Runtime Version])\r\n    let userAgent = \"Microsoft SignalR/\";\r\n    const majorAndMinor = version.split(\".\");\r\n    userAgent += `${majorAndMinor[0]}.${majorAndMinor[1]}`;\r\n    userAgent += ` (${version}; `;\r\n    if (os && os !== \"\") {\r\n        userAgent += `${os}; `;\r\n    }\r\n    else {\r\n        userAgent += \"Unknown OS; \";\r\n    }\r\n    userAgent += `${runtime}`;\r\n    if (runtimeVersion) {\r\n        userAgent += `; ${runtimeVersion}`;\r\n    }\r\n    else {\r\n        userAgent += \"; Unknown Runtime Version\";\r\n    }\r\n    userAgent += \")\";\r\n    return userAgent;\r\n}\r\n// eslint-disable-next-line spaced-comment\r\n/*#__PURE__*/ function getOsName() {\r\n    if (Platform.isNode) {\r\n        switch (process.platform) {\r\n            case \"win32\":\r\n                return \"Windows NT\";\r\n            case \"darwin\":\r\n                return \"macOS\";\r\n            case \"linux\":\r\n                return \"Linux\";\r\n            default:\r\n                return process.platform;\r\n        }\r\n    }\r\n    else {\r\n        return \"\";\r\n    }\r\n}\r\n// eslint-disable-next-line spaced-comment\r\n/*#__PURE__*/ function getRuntimeVersion() {\r\n    if (Platform.isNode) {\r\n        return process.versions.node;\r\n    }\r\n    return undefined;\r\n}\r\nfunction getRuntime() {\r\n    if (Platform.isNode) {\r\n        return \"NodeJS\";\r\n    }\r\n    else {\r\n        return \"Browser\";\r\n    }\r\n}\r\n/** @private */\r\nexport function getErrorString(e) {\r\n    if (e.stack) {\r\n        return e.stack;\r\n    }\r\n    else if (e.message) {\r\n        return e.message;\r\n    }\r\n    return `${e}`;\r\n}\r\n/** @private */\r\nexport function getGlobalThis() {\r\n    // globalThis is semi-new and not available in Node until v12\r\n    if (typeof globalThis !== \"undefined\") {\r\n        return globalThis;\r\n    }\r\n    if (typeof self !== \"undefined\") {\r\n        return self;\r\n    }\r\n    if (typeof window !== \"undefined\") {\r\n        return window;\r\n    }\r\n    if (typeof global !== \"undefined\") {\r\n        return global;\r\n    }\r\n    throw new Error(\"could not find global\");\r\n}\r\n//# sourceMappingURL=Utils.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform } from \"./Utils\";\r\n/** @private */\r\nexport class WebSocketTransport {\r\n    constructor(httpClient, accessTokenFactory, logger, logMessageContent, webSocketConstructor, headers) {\r\n        this._logger = logger;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n        this._logMessageContent = logMessageContent;\r\n        this._webSocketConstructor = webSocketConstructor;\r\n        this._httpClient = httpClient;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n        this._headers = headers;\r\n    }\r\n    async connect(url, transferFormat) {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._logger.log(LogLevel.Trace, \"(WebSockets transport) Connecting.\");\r\n        let token;\r\n        if (this._accessTokenFactory) {\r\n            token = await this._accessTokenFactory();\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            url = url.replace(/^http/, \"ws\");\r\n            let webSocket;\r\n            const cookies = this._httpClient.getCookieString(url);\r\n            let opened = false;\r\n            if (Platform.isNode || Platform.isReactNative) {\r\n                const headers = {};\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n                if (token) {\r\n                    headers[HeaderNames.Authorization] = `Bearer ${token}`;\r\n                }\r\n                if (cookies) {\r\n                    headers[HeaderNames.Cookie] = cookies;\r\n                }\r\n                // Only pass headers when in non-browser environments\r\n                webSocket = new this._webSocketConstructor(url, undefined, {\r\n                    headers: { ...headers, ...this._headers },\r\n                });\r\n            }\r\n            else {\r\n                if (token) {\r\n                    url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n                }\r\n            }\r\n            if (!webSocket) {\r\n                // Chrome is not happy with passing 'undefined' as protocol\r\n                webSocket = new this._webSocketConstructor(url);\r\n            }\r\n            if (transferFormat === TransferFormat.Binary) {\r\n                webSocket.binaryType = \"arraybuffer\";\r\n            }\r\n            webSocket.onopen = (_event) => {\r\n                this._logger.log(LogLevel.Information, `WebSocket connected to ${url}.`);\r\n                this._webSocket = webSocket;\r\n                opened = true;\r\n                resolve();\r\n            };\r\n            webSocket.onerror = (event) => {\r\n                let error = null;\r\n                // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                    error = event.error;\r\n                }\r\n                else {\r\n                    error = \"There was an error with the transport\";\r\n                }\r\n                this._logger.log(LogLevel.Information, `(WebSockets transport) ${error}.`);\r\n            };\r\n            webSocket.onmessage = (message) => {\r\n                this._logger.log(LogLevel.Trace, `(WebSockets transport) data received. ${getDataDetail(message.data, this._logMessageContent)}.`);\r\n                if (this.onreceive) {\r\n                    try {\r\n                        this.onreceive(message.data);\r\n                    }\r\n                    catch (error) {\r\n                        this._close(error);\r\n                        return;\r\n                    }\r\n                }\r\n            };\r\n            webSocket.onclose = (event) => {\r\n                // Don't call close handler if connection was never established\r\n                // We'll reject the connect call instead\r\n                if (opened) {\r\n                    this._close(event);\r\n                }\r\n                else {\r\n                    let error = null;\r\n                    // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                    if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                        error = event.error;\r\n                    }\r\n                    else {\r\n                        error = \"WebSocket failed to connect. The connection could not be found on the server,\"\r\n                            + \" either the endpoint may not be a SignalR endpoint,\"\r\n                            + \" the connection ID is not present on the server, or there is a proxy blocking WebSockets.\"\r\n                            + \" If you have multiple servers check that sticky sessions are enabled.\";\r\n                    }\r\n                    reject(new Error(error));\r\n                }\r\n            };\r\n        });\r\n    }\r\n    send(data) {\r\n        if (this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN) {\r\n            this._logger.log(LogLevel.Trace, `(WebSockets transport) sending data. ${getDataDetail(data, this._logMessageContent)}.`);\r\n            this._webSocket.send(data);\r\n            return Promise.resolve();\r\n        }\r\n        return Promise.reject(\"WebSocket is not in the OPEN state\");\r\n    }\r\n    stop() {\r\n        if (this._webSocket) {\r\n            // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\r\n            // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\r\n            this._close(undefined);\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    _close(event) {\r\n        // webSocket will be null if the transport did not start successfully\r\n        if (this._webSocket) {\r\n            // Clear websocket handlers because we are considering the socket closed now\r\n            this._webSocket.onclose = () => { };\r\n            this._webSocket.onmessage = () => { };\r\n            this._webSocket.onerror = () => { };\r\n            this._webSocket.close();\r\n            this._webSocket = undefined;\r\n        }\r\n        this._logger.log(LogLevel.Trace, \"(WebSockets transport) socket closed.\");\r\n        if (this.onclose) {\r\n            if (this._isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\r\n                this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason || \"no reason given\"}).`));\r\n            }\r\n            else if (event instanceof Error) {\r\n                this.onclose(event);\r\n            }\r\n            else {\r\n                this.onclose();\r\n            }\r\n        }\r\n    }\r\n    _isCloseEvent(event) {\r\n        return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\r\n    }\r\n}\r\n//# sourceMappingURL=WebSocketTransport.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpResponse } from \"./HttpClient\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\nexport class XhrHttpClient extends HttpClient {\r\n    constructor(logger) {\r\n        super();\r\n        this._logger = logger;\r\n    }\r\n    /** @inheritDoc */\r\n    send(request) {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new AbortError());\r\n        }\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            const xhr = new XMLHttpRequest();\r\n            xhr.open(request.method, request.url, true);\r\n            xhr.withCredentials = request.withCredentials === undefined ? true : request.withCredentials;\r\n            xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\r\n            if (request.content === \"\") {\r\n                request.content = undefined;\r\n            }\r\n            if (request.content) {\r\n                // Explicitly setting the Content-Type header for React Native on Android platform.\r\n                if (isArrayBuffer(request.content)) {\r\n                    xhr.setRequestHeader(\"Content-Type\", \"application/octet-stream\");\r\n                }\r\n                else {\r\n                    xhr.setRequestHeader(\"Content-Type\", \"text/plain;charset=UTF-8\");\r\n                }\r\n            }\r\n            const headers = request.headers;\r\n            if (headers) {\r\n                Object.keys(headers)\r\n                    .forEach((header) => {\r\n                    xhr.setRequestHeader(header, headers[header]);\r\n                });\r\n            }\r\n            if (request.responseType) {\r\n                xhr.responseType = request.responseType;\r\n            }\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = () => {\r\n                    xhr.abort();\r\n                    reject(new AbortError());\r\n                };\r\n            }\r\n            if (request.timeout) {\r\n                xhr.timeout = request.timeout;\r\n            }\r\n            xhr.onload = () => {\r\n                if (request.abortSignal) {\r\n                    request.abortSignal.onabort = null;\r\n                }\r\n                if (xhr.status >= 200 && xhr.status < 300) {\r\n                    resolve(new HttpResponse(xhr.status, xhr.statusText, xhr.response || xhr.responseText));\r\n                }\r\n                else {\r\n                    reject(new HttpError(xhr.response || xhr.responseText || xhr.statusText, xhr.status));\r\n                }\r\n            };\r\n            xhr.onerror = () => {\r\n                this._logger.log(LogLevel.Warning, `Error from HTTP request. ${xhr.status}: ${xhr.statusText}.`);\r\n                reject(new HttpError(xhr.statusText, xhr.status));\r\n            };\r\n            xhr.ontimeout = () => {\r\n                this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                reject(new TimeoutError());\r\n            };\r\n            xhr.send(request.content);\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=XhrHttpClient.js.map","import { GetNewResolutions } from \"@root/share/GetNewResolutions\"\r\nimport { StartVideoMedia } from \"./StartVideoMedia\"\r\n\r\nexport class CanvasVideo {\r\n    private resolution: { [key: string]: number };\r\n    point: number = 25000;\r\n    myMovingPoint: number = 0;\r\n    targetPoint: number = 0;\r\n    calcPoint: number = 0;\r\n    leftCalcPoint: number = 0;\r\n    isCaliculate: boolean = false;\r\n    resultCd: string = \"0\";\r\n    private image: HTMLImageElement;\r\n    private title: string;\r\n    private name: string;\r\n    private videoNumber: number;\r\n    private canvasResolutions: { [key: string]: { [key: string]: number } } = {};\r\n\r\n    private canvas: HTMLCanvasElement | null = null;\r\n    private ctx: CanvasRenderingContext2D | null = null;\r\n    private videoElement: HTMLVideoElement | null = null;\r\n    private isPointView: boolean = false;\r\n\r\n    private resultDic: { [key: string]: string } = {\r\n        \"0\": \"　\",\r\n        \"1\": \"ツモ\",\r\n        \"2\": \"ロン\",\r\n        \"3\": \"放銃\",\r\n        \"30\": \"流局\",\r\n        \"31\": \"聴牌\",\r\n        \"32\": \"ノーテン\",\r\n        \"33\": \"四風連打\" ,\r\n        \"34\": \"九種九牌\" ,\r\n        \"35\": \"四家立直\" ,\r\n        \"36\": \"四開槓\" ,\r\n        \"21\": \"ダブロン\" ,\r\n        \"22\": \"トリロン\",\r\n    };\r\n\r\n    constructor(title: string, name: string, videoNumber: number, point: number = 25000) {\r\n    // 解像度を設定\r\n        //this.resolution = { w: 1280, h: 960 };\r\n        this.resolution = { w: 800, h: 600 };\r\n\r\n        // canvasのwrapperサイズを取得\r\n        const canvasWrapperElement = document.getElementById(\"canvas\" + videoNumber + \"Wrapper\") as HTMLElement;\r\n        this.canvasResolutions = GetNewResolutions.Get(canvasWrapperElement, this.resolution, \"VGA\");\r\n\r\n        this.image = new Image();\r\n        this.title = title;\r\n        this.name = name;\r\n        this.videoNumber = videoNumber;\r\n        this.point = point;\r\n    }\r\n\r\n    activateCanvas = async () => {\r\n        // 選択されているカメラの取得\r\n        const myCameraSelectorElement = document.getElementById(\r\n            \"cameraSelector\" + this.videoNumber\r\n        ) as HTMLInputElement;\r\n        const startVideoMedia = new StartVideoMedia();\r\n        this.videoElement = await startVideoMedia.setVideo(\r\n            myCameraSelectorElement.value,\r\n            \"video_\" + this.videoNumber,\r\n            this.resolution.w,\r\n            this.resolution.h\r\n        );\r\n\r\n        return await this.makeCanvasVideo();\r\n    }\r\n\r\n    private makeCanvasVideo = async () => {\r\n        // canvas要素を取得\r\n        this.canvas = document.getElementById(\"canvasVideo_\" + this.videoNumber) as HTMLCanvasElement;\r\n        this.canvas.width = this.canvasResolutions[\"canvas\"].w;\r\n        this.canvas.height = this.canvasResolutions[\"canvas\"].h;\r\n\r\n        // コンテキストを取得する\r\n        this.ctx = this.canvas.getContext('2d')!;\r\n\r\n        // imageを読み込む\r\n        await this.loadImage();\r\n\r\n        // fixme 画像はそれごとに変えます コレの変更機能は後で\r\n        this.image.src = \"/image/pict1.png\";\r\n\r\n        this.isPointView = false;\r\n\r\n        return this.drawCanvas();\r\n    }\r\n\r\n    // 一度ActivateしたあとはCanvasの描画だけ行うのでこのメソッドはPublic\r\n    drawCanvas = () => {\r\n        if (this.canvas && this.ctx) {\r\n            if (this.videoElement === null) {\r\n                throw new Error(\"video_\" + this.videoNumber + \"is not exist\");\r\n            }\r\n            this.ctx.globalAlpha = 1;\r\n            // バックグラウンド表示\r\n            this.ctx.fillStyle = \"black\";\r\n            this.ctx.fillRect(\r\n                0,\r\n                0,\r\n                this.canvasResolutions[\"canvas\"].w,\r\n                this.canvasResolutions[\"canvas\"].h\r\n            );\r\n\r\n            // video表示\r\n            this.ctx.drawImage(\r\n                this.videoElement,\r\n                this.canvasResolutions[\"video\"].x,\r\n                this.canvasResolutions[\"video\"].y,\r\n                this.canvasResolutions[\"video\"].w,\r\n                this.canvasResolutions[\"video\"].h\r\n            );\r\n\r\n            // isCaliculateがONになったら点数移動の計算を行う\r\n            if (this.isCaliculate) {\r\n                this.pointMovingProcess();\r\n            }\r\n\r\n            // 文字枠表示\r\n            this.ctx.globalAlpha = 0.5;\r\n            this.ctx.fillRect(\r\n                this.canvasResolutions[\"characterFrame\"].x,\r\n                this.canvasResolutions[\"characterFrame\"].y,\r\n                this.canvasResolutions[\"characterFrame\"].w,\r\n                this.canvasResolutions[\"characterFrame\"].h\r\n            );\r\n            // 画像表示\r\n            this.ctx.globalAlpha = 1;\r\n            this.ctx.drawImage(\r\n                this.image,\r\n                this.canvasResolutions[\"face\"].x,\r\n                this.canvasResolutions[\"face\"].y,\r\n                this.canvasResolutions[\"face\"].w,\r\n                this.canvasResolutions[\"face\"].h\r\n            );\r\n            this.ctx.textAlign = \"end\";\r\n            this.ctx.fillStyle = \"white\";\r\n            if (this.isPointView) {\r\n                this.ctx.font = this.canvasResolutions[\"kind\"].font.toString(),  + 'px monospace';\r\n                this.ctx.fillText(\r\n                    this.resultDic[this.resultCd],\r\n                    this.canvasResolutions[\"kind\"].x,\r\n                    this.canvasResolutions[\"kind\"].y\r\n                );\r\n                this.ctx.fillText(\r\n                    this.myMovingPoint.toString(),\r\n                    this.canvasResolutions[\"movingPoint\"].x,\r\n                    this.canvasResolutions[\"movingPoint\"].y\r\n                );\r\n                this.ctx.font = this.canvasResolutions[\"allow\"].font.toString() + 'px monospace';\r\n                this.ctx.fillText(\r\n                    \"↓\",\r\n                    this.canvasResolutions[\"allow\"].x,\r\n                    this.canvasResolutions[\"allow\"].y\r\n                );\r\n                this.ctx.textAlign = \"end\";\r\n            } else {\r\n                this.ctx.font = this.canvasResolutions[\"title\"].font.toString() + 'px monospace';\r\n                this.ctx.fillText(\r\n                    this.title,\r\n                    this.canvasResolutions[\"title\"].x,\r\n                    this.canvasResolutions[\"title\"].y,\r\n                );\r\n                this.ctx.font = this.canvasResolutions[\"name\"].font.toString() + 'px monospace';\r\n                this.ctx.fillText(\r\n                    this.name,\r\n                    this.canvasResolutions[\"name\"].x,\r\n                    this.canvasResolutions[\"name\"].y\r\n                );\r\n            }\r\n\r\n            this.ctx.font = this.canvasResolutions[\"point\"].font.toString()  + 'px monospace';\r\n            this.ctx!.fillText(\r\n                this.point.toLocaleString(),\r\n                this.canvasResolutions[\"point\"].x,\r\n                this.canvasResolutions[\"point\"].y\r\n            );\r\n        }\r\n    }\r\n\r\n    private loadImage = async () => {\r\n        return this.image.addEventListener(\"load\", () => { });\r\n    }\r\n\r\n    private pointMovingProcess = () => {\r\n        this.isPointView = true;\r\n\r\n        if (this.calcPoint !== 0) {\r\n            this.leftCalcPoint -= this.calcPoint;\r\n            this.point += this.calcPoint;\r\n        }\r\n\r\n        if (this.myMovingPoint < 0) {\r\n            // 現ポイントがtargetPointより小さくなるまでfalse\r\n            this.isCaliculate = this.point > this.targetPoint;\r\n        } else {\r\n            // 現ポイントがtargetPointより大きくなるまでfalse\r\n            this.isCaliculate = this.point < this.targetPoint;\r\n        }\r\n\r\n        if (!this.isCaliculate) {\r\n            this.leftCalcPoint = 0;\r\n            this.calcPoint = 0;\r\n            this.point = this.targetPoint;\r\n            this.targetPoint = 0;\r\n            window.setTimeout(() => {\r\n                this.myMovingPoint = 0;\r\n                this.isPointView = false;\r\n            }, 1000 * 2);\r\n        }\r\n    }\r\n}","import { ControlModal } from \"@root/share/ControlModal\"\r\n\r\nexport class EventControlModal {\r\n    static setModal = () => {\r\n        document.getElementById(\"painList\")?.classList.remove(\"nodisplay\");\r\n\r\n        document.getElementById(\"painButton\")?.addEventListener(\"click\", () => {\r\n            document.getElementById(\"listModalWrapper\")!.classList.remove(\"hidden\");\r\n        });\r\n\r\n       const listControlModal = new ControlModal(\r\n           \"#painButton\",\r\n            \"list\",\r\n        );\r\n\r\n        const endHandControlModal = new ControlModal(\r\n            \"#listEndHandButton\",\r\n            \"endHand\",\r\n        );\r\n\r\n        const videoTestModal = new ControlModal(\r\n            \"#showVideoTestButton\",\r\n            \"videoTest\",\r\n        );\r\n\r\n        const showPointModal = new ControlModal(\r\n            \"#showPointButton\",\r\n            \"showPoint\",\r\n        );\r\n\r\n        const videoRegisterModal = new ControlModal(\r\n            \"#videoRegisterButton\",\r\n            \"videoRegister\",\r\n        );\r\n\r\n        listControlModal.setControl();\r\n        endHandControlModal.setControl();\r\n        videoTestModal.setControl();\r\n        showPointModal.setControl();\r\n        videoRegisterModal.setControl();\r\n    }\r\n}","import { SetEventListner } from \"@root/share/SetEventListner\"\r\nimport { FetchApi } from \"@root/share/FetchApi\";\r\nimport { GetCameraInformation } from \"./GetCameraInformation\"\r\n\r\nexport class GetCamera {\r\n    url: string;\r\n    method: string;\r\n    headers: { [key: string]: string };\r\n    responseKind: string;\r\n    getCameraProperty: {\r\n        [key: string]: string |\r\n        string[] |\r\n        { [key: string]: string } |\r\n        { [key: string]: string }[] |\r\n        null\r\n    } = {\r\n        EventNumber: null,\r\n        GameNumber: null,\r\n        CameraContainer: null\r\n    };\r\n    cameraContainer: { [key: string]: string }[] = [];\r\n\r\n    constructor() {\r\n        this.url = '/Event/GetCamera';\r\n        this.method = 'POST';\r\n        this.headers = {\r\n            \"Content-Type\": \"application/json\",\r\n            'X-Requested-With': 'XMLHttpRequest'\r\n        };\r\n        this.responseKind = \"text\";\r\n\r\n        this.getCameraProperty.EventNumber\r\n            = (<HTMLInputElement>document.getElementById(\"eventNumber\")).value;\r\n\r\n        this.getCameraProperty.GameNumber\r\n            = (<HTMLInputElement>document.getElementById(\"gameNumber\")).value;\r\n    }\r\n\r\n    static cameraContainer: { [key: string]: string }[] = [];\r\n\r\n    setGetCamerEvent = () => {\r\n        SetEventListner.setEvent(\r\n            document.getElementById(\"listModalWindow\"),\r\n            \"click\",\r\n            \"#getCameraButton\",\r\n            async () => {\r\n                this.getCameraProperty.CameraContainer = await GetCameraInformation.setDevices();\r\n                const videoHtml = await this.get();\r\n\r\n                document.getElementById(\"listModalWindow\")!.innerHTML = videoHtml;\r\n            }\r\n        );\r\n    }\r\n\r\n    private get = async () => {\r\n        const fetchApi = new FetchApi();\r\n\r\n        return await fetchApi.send(\r\n            this.url,\r\n            this.method,\r\n            this.headers,\r\n            this.getCameraProperty,\r\n            this.responseKind\r\n        ).then(async (data: string ) => {\r\n            return data;\r\n        }).catch(e => {\r\n            throw e;\r\n        });\r\n    }\r\n}","export class GetCameraInformation {\r\n    static cameraContainer: { [key: string]: string }[] = [];\r\n\r\n    static setDevices = async () => {\r\n        const devices = (await navigator.mediaDevices.enumerateDevices());\r\n        GetCameraInformation.cameraContainer = [];\r\n        devices.forEach(device => {\r\n            if (device.kind !== \"videoinput\") {\r\n                return;\r\n            }\r\n            GetCameraInformation.cameraContainer.push({\r\n                deviceId: device.deviceId,\r\n                label: device.label\r\n            });\r\n        });\r\n        return GetCameraInformation.cameraContainer;\r\n    }\r\n\r\n    static createCameraSelectorObject = (selectObject: Element) => {\r\n        if (selectObject.childElementCount > 0) {\r\n            Array.from(selectObject.children).forEach((element: Element) => {\r\n                element.remove();\r\n            });\r\n        }\r\n        GetCameraInformation.cameraContainer.forEach((camera) => {\r\n            const cameraOptionElement = document.createElement(\"option\");\r\n            cameraOptionElement.value = camera.deviceId;\r\n            cameraOptionElement.text = camera.label;\r\n            selectObject.appendChild(cameraOptionElement);\r\n        });\r\n    }\r\n}","import { FetchApi } from \"@root/share/FetchApi\";\r\nimport { StartVideoMedia } from \"./StartVideoMedia\";\r\nimport { GetCameraInformation } from \"./GetCameraInformation\";\r\n\r\nexport class RegisterVideo {\r\n    cameraContainer: { [key: string]: string }[] = [];\r\n    url: string;\r\n    method: string;\r\n    headers: { [key: string]: string };\r\n    responseKind: string;\r\n    registerVideoProperty: {\r\n        [key: string]: string | null\r\n    } = {\r\n            DeviceId: null,\r\n            Label: null,\r\n            CameraName: null\r\n    };\r\n\r\n    constructor() {\r\n        this.url = '/Event/RegisterVideo';\r\n        this.method = 'POST';\r\n        this.headers = {\r\n            \"Content-Type\": \"application/json\",\r\n            'X-Requested-With': 'XMLHttpRequest'\r\n        };\r\n        this.responseKind = \"json\";\r\n    }\r\n\r\n    setRegisterVideoEvent = async () => {\r\n        let videoElement: HTMLVideoElement;\r\n\r\n        document.getElementById(\"getRegisterVideoSelectorButton\")?.addEventListener(\"click\", async () => {\r\n            // 接続済カメラデバイスを取得、クラスPropertyにIDをセット\r\n            this.cameraContainer = await GetCameraInformation.setDevices();\r\n\r\n            // カメラ選択optionElementをセット\r\n            let cameraSelector = document.getElementById(\"registerVideoList\") as HTMLSelectElement;\r\n\r\n            GetCameraInformation.createCameraSelectorObject(cameraSelector);\r\n\r\n            // カメラを取得、Optionにセットしたら画面を表示\r\n            document.getElementById(\"startRegisterVideoButton\")!.classList.remove(\"hidden\");\r\n        });\r\n\r\n        document.getElementById(\"startRegisterVideoButton\")?.addEventListener(\"click\", async () => {\r\n            const nowCamera = document.getElementById(\"registerVideoList\") as HTMLSelectElement;\r\n            const startVideoMedia = new StartVideoMedia();\r\n            videoElement = await startVideoMedia.setVideo(\r\n                nowCamera.value,\r\n                \"registerVideo\",\r\n                320,\r\n                240\r\n            );\r\n        });\r\n\r\n        // ビデオ停止\r\n        document.getElementById(\"stopRegiterVideoButton\")?.addEventListener(\"click\", async () => {\r\n            videoElement.pause();\r\n            videoElement.load();\r\n            const source = videoElement.querySelector(\"source\");\r\n            if (source != null) {\r\n                source.src = \"\";\r\n                videoElement.load();\r\n            }\r\n        });\r\n\r\n        // ビデオ登録\r\n        document.getElementById(\"registerVideoInformationButton\")?.addEventListener(\"click\", async () => {\r\n            const cameraElement = document.getElementById(\"registerVideoList\") as HTMLSelectElement;\r\n            const selectedIndex = cameraElement.selectedIndex;\r\n            const cameraNameElement = document.getElementById(\"registerCameraName\") as HTMLInputElement;\r\n\r\n            this.registerVideoProperty.CameraName = cameraNameElement.value;\r\n            this.registerVideoProperty.DeviceId = cameraElement.value;\r\n            this.registerVideoProperty.Label = cameraElement.options[selectedIndex].text;\r\n\r\n            this.setRegisterVideo();\r\n        });\r\n    }\r\n\r\n    private setRegisterVideo = async (): Promise<void> => {\r\n        const fetchApi = new FetchApi();\r\n\r\n        return await fetchApi.send(\r\n            this.url,\r\n            this.method,\r\n            this.headers,\r\n            this.registerVideoProperty,\r\n            this.responseKind\r\n        ).then(async (data: boolean) => {\r\n            if (data) {\r\n                alert(\"register complete\");\r\n            }\r\n        }).catch(e => {\r\n            throw e;\r\n        });\r\n    }\r\n}","import { FetchApi } from \"@root/share/FetchApi\";\r\nimport { SetEventListner } from \"@root/share/SetEventListner\";\r\n\r\nexport class StartGame {\r\n    url: string;\r\n    method: string;\r\n    headers: { [key: string]: string };\r\n    responseKind: string;\r\n    startGameProperty: {\r\n        [key: string]: string |\r\n        string[] |\r\n        { [key: string]: string } |\r\n        null\r\n    } = {\r\n        EventNumber: null,\r\n        HandNumber: null,\r\n        HandSubNumber: null,\r\n        UsersList: null,\r\n        DirectionDictionary: null,\r\n        VideoDictionary: null,\r\n        VideoNumberDictionary: null\r\n    };\r\n\r\n    constructor() {\r\n        this.url = '/Event/StartGame';\r\n        this.method = 'POST';\r\n        this.headers = {\r\n            \"Content-Type\": \"application/json\",\r\n            'X-Requested-With': 'XMLHttpRequest'\r\n        };\r\n        this.responseKind = \"json\";\r\n\r\n        this.startGameProperty.EventNumber\r\n            = (<HTMLInputElement>document.getElementById(\"eventNumber\")).value;\r\n    }\r\n\r\n    setStartEvent = () => {\r\n        SetEventListner.setEvent(\r\n            document.getElementById(\"listModalWindow\"),\r\n            \"click\",\r\n            \"#listStartGameButton\",\r\n            () => {\r\n                this.start().then((data: { [key: string]: string }) => {\r\n                    this.setGameData(data);\r\n                });\r\n            }\r\n        );\r\n    }\r\n\r\n    private setGameData = (data: {[key:string]: string}) => {\r\n        console.log(data);\r\n        const gameData = data[\"gameData\"];\r\n        const videoController = data[\"videoController\"];\r\n        const gameDataElement = <HTMLElement>document.getElementById(\"mainContents\")\r\n        const videoControllElement = <HTMLElement>document.getElementById(\"listModalWindow\");\r\n\r\n        gameDataElement.innerHTML = gameData;\r\n        videoControllElement.innerHTML = videoController;\r\n    }\r\n\r\n    private start = async (): Promise<{ [key: string]: string }> => {\r\n        let userList: string[] = [];\r\n        let directionDic: { [key: string]: string } = {};\r\n        let videoDic: { [key: string]: string } = {};\r\n        let videoNumberDic: { [key: string]: string } = {};\r\n        const userListElement = document.getElementsByClassName(\"userList\");\r\n        if (userListElement.length) {\r\n            Array.from(userListElement).forEach((userElement, index) => {\r\n                const userCd = (<HTMLSelectElement>userElement).value;\r\n                const directionElement = (<HTMLSelectElement>userElement)\r\n                    .closest(\".videoController\")!\r\n                    .querySelector(\".directionList\")\r\n                    ;\r\n                const VideoElement = (<HTMLSelectElement>userElement)\r\n                    .closest(\".videoController\")!\r\n                    .querySelector(\".cameraSelector\")\r\n                    ;\r\n                if (userCd == \"99\") {\r\n                    // 天吊のコードを除外\r\n                    return;\r\n                }\r\n                if (userList.length >= 4) {\r\n                    return;\r\n                }\r\n                userList.push(userCd);\r\n                directionDic[userCd] = (<HTMLSelectElement>directionElement).value;\r\n                videoDic[userCd] = (<HTMLSelectElement>VideoElement).value;\r\n                videoNumberDic[userCd] = index.toString();\r\n            });\r\n\r\n            const checkUserCount = Array.from(new Set(userList));\r\n            if (checkUserCount.length < 4) {\r\n                alert(\"ユーザーが重複しています\");\r\n                throw new Error(\"user Duplicated\");\r\n            }\r\n        }\r\n        this.startGameProperty.UsersList = userList;\r\n        this.startGameProperty.DirectionDictionary = directionDic;\r\n        this.startGameProperty.VideoDictionary = videoDic;\r\n        this.startGameProperty.VideoNumberDictionary = videoNumberDic;\r\n\r\n        this.startGameProperty.HandNumber\r\n            = (<HTMLInputElement>document.getElementById(\"handNumber\")).value;\r\n\r\n        this.startGameProperty.HandSubNumber\r\n            = (<HTMLInputElement>document.getElementById(\"handSubNumber\")).value;\r\n\r\n        const startGameProperty = new StartGameProperty(\r\n            parseInt((<HTMLInputElement>document.getElementById(\"eventNumber\")).value),\r\n            userList,\r\n            directionDic\r\n        );\r\n\r\n        const fetchApi = new FetchApi();\r\n\r\n        return await fetchApi.send(\r\n            this.url,\r\n            this.method,\r\n            this.headers,\r\n            this.startGameProperty,\r\n            this.responseKind\r\n        ).then(async (data: { [key: string]: string}) => {\r\n            return data;\r\n        }).catch(e => {\r\n            throw e;\r\n        });\r\n    }\r\n}\r\n\r\nclass StartGameProperty {\r\n    EventNumber: number;\r\n    UsersList: string[] | null;\r\n    DirectionDictionary: { [key: string]: string } | null;\r\n\r\n    constructor(\r\n        EventNumber: number,\r\n        UsersList: string[] | null,\r\n        DirectionDictionary: { [key: string]: string } | null\r\n    ) {\r\n        this.EventNumber = EventNumber;\r\n        this.UsersList = UsersList;\r\n        this.DirectionDictionary = DirectionDictionary;\r\n    }\r\n}","export class StartVideoMedia {\r\n    setVideo = async (\r\n        deviceId: string,\r\n        videoElementId: string,\r\n        resolutionWidth: number,\r\n        resolutionHeight: number\r\n    ) => {\r\n        // video要素を取得\r\n        const videoElement = document.getElementById(videoElementId) as HTMLVideoElement;\r\n\r\n        // video要素にWebカメラの映像を表示させる\r\n        return await navigator.mediaDevices.getUserMedia({\r\n            audio: false,\r\n            video: {\r\n                width: { ideal: resolutionWidth },\r\n                height: { ideal: resolutionHeight },\r\n                deviceId: deviceId\r\n            }\r\n        }).then(async (stream: MediaStream) => {\r\n            if (videoElement === null) {\r\n                throw new Error(\"video_\" + videoElement + \"is not exist\");\r\n            }\r\n\r\n            videoElement.srcObject = stream;\r\n            videoElement.play();\r\n            return videoElement;\r\n        });\r\n    }\r\n}\r\n","import { SignalR } from \"@root/share/SignalR\";\r\nimport { SetEventListner } from \"@root/share/SetEventListner\"\r\nimport { FetchApi } from \"@root/share/FetchApi\";\r\nimport { CanvasVideo } from \"./CanvasVideo\"\r\n\r\nexport class VideoControll {\r\n    cameraContainer: { [key: string]: string }[] = [];\r\n    fps: number = 60;\r\n    intervalId: number = 0;\r\n\r\n    url: string;\r\n    method: string;\r\n    headers: { [key: string]: string };\r\n    responseKind: string;\r\n\r\n    constructor() {\r\n        this.url = '/Event/GetVideoUsers';\r\n        this.method = 'POST';\r\n        this.headers = {\r\n            \"Content-Type\": \"application/json\",\r\n            'X-Requested-With': 'XMLHttpRequest'\r\n        };\r\n        this.responseKind = \"json\";\r\n    }\r\n\r\n    controlVideoEvent = async (signalR: SignalR) => {\r\n        // 接続済カメラデバイスを取得、クラスPropertyにIDをセット\r\n        await this.setDevices();\r\n\r\n        // カメラ選択optionElementをセット\r\n        const cameraSelectors = document.getElementsByClassName(\"cameraSelector\");\r\n        Array.from(cameraSelectors).forEach(cameraSelector => {\r\n            this.createCameraSelectorObject(cameraSelector);\r\n        });\r\n\r\n        // カメラを取得、Optionにセットしたら画面を表示\r\n        document.getElementById(\"mainContents\")!.classList.remove(\"hidden\");\r\n\r\n        if (document.getElementById(\"gameNumber\") === null || (<HTMLInputElement>document.getElementById(\"gameNumber\")!).value === \"\") {\r\n            return;\r\n        }\r\n        const eventNumber = (<HTMLInputElement>document.getElementById(\"eventNumber\")!).value;\r\n        const gameNumber = (<HTMLInputElement>document.getElementById(\"gameNumber\")!).value;\r\n\r\n        const fetchApi = new FetchApi();\r\n\r\n        const setting = await fetchApi.send(\r\n            this.url,\r\n            this.method,\r\n            this.headers,\r\n            {\r\n                EventNumber: eventNumber,\r\n                GameNumber: gameNumber\r\n            },\r\n            this.responseKind\r\n        ).then(async (data: { [key: string]: string | number }[]) => {\r\n            return data;\r\n        }).catch(e => {\r\n            throw e;\r\n        });\r\n\r\n        /*\r\n        const setting = [\r\n            {\r\n                title: \"またしても何も知らない\",\r\n                name: \"大泉洋\"\r\n            },\r\n            {\r\n                title: \"投げる同人作家\",\r\n                name: \"佐々木貴賀\"\r\n            },\r\n            {\r\n                title: \"それでも何もしてくれない\",\r\n                name: \"荒巻スカルチノフ\"\r\n            },\r\n            {\r\n                title: \"世界でしか通用しない男\",\r\n                name: \"小林誠司\"\r\n            },\r\n            {\r\n                title: \"\",\r\n                name: \"\"\r\n            },\r\n        ];\r\n        */\r\n        let canvasVideoArray: (CanvasVideo | null)[]  = [];\r\n\r\n        for (let i = 0; i < 5; i++) {\r\n            canvasVideoArray.push(null);\r\n            // video有効・無効イベントのセット\r\n            SetEventListner.setEvent(\r\n                document.getElementById(\"listModalWindow\"),\r\n                \"change\",\r\n                \"#video\" + i + \"Checker\",\r\n                async event => {\r\n                    this.setVideoInstance(\r\n                        <HTMLInputElement>event.target,\r\n                        canvasVideoArray,\r\n                        <string>setting[i].userTitle,\r\n                        <string>setting[i].userName,\r\n                        i,\r\n                        <number>setting[i].point\r\n                    );\r\n                }\r\n            );\r\n        }\r\n\r\n        // canvasVideoArray\r\n        signalR.get(\"SendEndHandResultEntityList\", endHandResultEntityListJson => {\r\n            console.log(endHandResultEntityListJson);\r\n            endHandResultEntityListJson = <{ [key: string]: string | number }[]>endHandResultEntityListJson;\r\n            endHandResultEntityListJson\r\n                .filter(x => x[\"videoNumber\"] != null && canvasVideoArray[<number>x[\"videoNumber\"]] != null)\r\n                .forEach((endHandResultEntity, index) => {\r\n                    this.setUserData(canvasVideoArray[<number>endHandResultEntity[\"videoNumber\"]]!, endHandResultEntity);\r\n                });\r\n        });\r\n\r\n        (document.getElementById(\"video0Button\") as HTMLButtonElement).addEventListener(\r\n            \"click\",\r\n            () => {\r\n                if (canvasVideoArray[0] == null) {\r\n                    return;\r\n                }\r\n                canvasVideoArray[0].myMovingPoint = -48000;\r\n                canvasVideoArray[0].isCaliculate = true;\r\n                canvasVideoArray[0].targetPoint = canvasVideoArray[0].point + canvasVideoArray[0].myMovingPoint;\r\n                canvasVideoArray[0].calcPoint =\r\n                    Math.floor(\r\n                        canvasVideoArray[0].myMovingPoint / (this.fps * 3)\r\n                    );\r\n                canvasVideoArray[0].leftCalcPoint = canvasVideoArray[0].myMovingPoint;\r\n            }\r\n        )\r\n\r\n        // videoの表示サイズ変更　厳密にはここじゃない気もする\r\n        SetEventListner.setEvent(\r\n            document.getElementById(\"listModalWindow\"),\r\n            \"change\",\r\n            \"#videoSize\",\r\n            async event => {\r\n                this.changeVideoSize();\r\n                // 再生領域全体を確認して、チェックが付いていたら再生し直す\r\n                for (let i = 0; i < 5; i++) {\r\n                    canvasVideoArray.push(null);\r\n                    this.setVideoInstance(\r\n                        (document.getElementById(\"video\" + i + \"Checker\")! as HTMLInputElement),\r\n                        canvasVideoArray,\r\n                        <string>setting[i].title,\r\n                        <string>setting[i].name,\r\n                        i,\r\n                        <number>setting[i].point\r\n                    );\r\n                }\r\n            }\r\n        )\r\n    }\r\n\r\n    private setVideoInstance = async (\r\n        elemnt: HTMLInputElement,\r\n        canvasVideoArray: (CanvasVideo | null)[],\r\n        title: string,\r\n        name: string,\r\n        videoNumber: number,\r\n        point: number\r\n    ) => {\r\n        if (elemnt.checked) {\r\n            // 有効になったCanvasのインスタンス生成\r\n            const canvasVideo = new CanvasVideo(title, name, videoNumber, point);\r\n            canvasVideoArray[videoNumber] = canvasVideo;\r\n            if (this.intervalId) {\r\n                // 一瞬SetIntervalを止めてリフレッシュ\r\n                clearInterval(this.intervalId);\r\n            }\r\n            canvasVideo.activateCanvas();\r\n            await this.setDrawCanvas(canvasVideoArray).then((setInterValId: number) => {\r\n                this.intervalId = setInterValId\r\n            });\r\n            // 有効になったVideoのcvenableをTrueに\r\n            document.getElementById(\"canvasVideo_\" + videoNumber)!.dataset.cvenable = \"1\";\r\n        } else {\r\n            canvasVideoArray[videoNumber] = null;\r\n            document.getElementById(\"canvasVideo_\" + videoNumber)!.dataset.cvenable = \"0\";\r\n        }\r\n    }\r\n    \r\n    private setDevices = async () => {\r\n        const devices = (await navigator.mediaDevices.enumerateDevices());\r\n        devices.forEach(device => {\r\n            if (device.kind !== \"videoinput\") {\r\n                return;\r\n            }\r\n            this.cameraContainer.push(\r\n                {\r\n                    deviceId: device.deviceId,\r\n                    label: device.label\r\n                }\r\n            )\r\n        });\r\n    }\r\n\r\n    private createCameraSelectorObject = (selectObject: Element) => {\r\n        this.cameraContainer.forEach((camera) => {\r\n            const cameraOptionElement = document.createElement(\"option\");\r\n            cameraOptionElement.value = camera.deviceId;\r\n            cameraOptionElement.text = camera.label;\r\n            selectObject.appendChild(cameraOptionElement);\r\n        });\r\n    }\r\n\r\n    private changeVideoSize = () => {\r\n        const videoSize = (document.getElementById(\"videoSize\") as HTMLInputElement).value;\r\n        const videoWrapperElements = document.getElementsByClassName(\"videoWrapper\");\r\n\r\n        // 画面をすべて表示 クラスを一度すべて削除してつけなおし\r\n        Array.from(videoWrapperElements).forEach((element: Element, index: number) => {\r\n            element.classList.remove(...element.classList);\r\n            element.classList.add(\"videoWrapper\");\r\n\r\n            switch (videoSize) {\r\n                case \"small\":\r\n                    element.classList.add(\"small\");\r\n                    break;\r\n                case \"filmtsrip\":\r\n                    // 一画面を大きく表示して外を並べる\r\n                    element.classList.add(\"filmtsrip\");\r\n                    break;\r\n                case \"middle\":\r\n                    element.classList.add(\"middle\");\r\n\r\n                    // 4画面目までは削除しない\r\n                    if (index < 4) {\r\n                            return;\r\n                    }\r\n\r\n                    // videoを停止して非表示\r\n                    (document.getElementById(\"video\" + index + \"Checker\") as HTMLInputElement).checked = false;\r\n                    element.classList.add(\"nodisplay\");\r\n                    break;\r\n                case \"large\":\r\n                    element.classList.add(\"large\");\r\n                    // 1画面目は残す\r\n                    if (index < 1) {\r\n                        return;\r\n                    }\r\n\r\n                    // videoを停止して非表示\r\n                    (document.getElementById(\"video\" + index + \"Checker\") as HTMLInputElement).checked = false;\r\n                    element.classList.add(\"nodisplay\");\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n\r\n    private setDrawCanvas = async (canvasVideoArray: (CanvasVideo | null)[]) => {\r\n        return await window.setInterval(() => {\r\n            canvasVideoArray.forEach(canvasVideo => {\r\n                if (canvasVideo !== null){\r\n                    canvasVideo.drawCanvas();\r\n                }\r\n            });\r\n        }, 1000 / this.fps);\r\n    }\r\n\r\n    private setUserData = (canvasVideo: CanvasVideo, endHandResultEntity: {[key:string]: string | number}) => {\r\n        setTimeout(() => {\r\n            canvasVideo.myMovingPoint = <number>endHandResultEntity[\"movingPoint\"];\r\n            canvasVideo.targetPoint = <number>endHandResultEntity[\"point\"];\r\n            canvasVideo.isCaliculate = true;\r\n            canvasVideo.calcPoint = Math.floor(\r\n                canvasVideo.myMovingPoint / 60 * 5\r\n            );\r\n            canvasVideo.leftCalcPoint = canvasVideo.myMovingPoint;\r\n            canvasVideo.resultCd = <string>endHandResultEntity[\"resultCd\"];\r\n        }, 3000);\r\n    }\r\n}","import { StartVideoMedia } from \"./StartVideoMedia\";\r\n\r\nexport class VideoTestControll {\r\n    cameraContainer: { [key: string]: string }[] = [];\r\n    fps: number = 60;\r\n    intervalId: number = 0;\r\n\r\n    setTestVideoEvent = async () => {\r\n\r\n        let videoElement: HTMLVideoElement;\r\n\r\n        document.getElementById(\"getTestVideoSelector\")?.addEventListener(\"click\", async () => {\r\n            // 接続済カメラデバイスを取得、クラスPropertyにIDをセット\r\n            await this.setDevices();\r\n\r\n            // カメラ選択optionElementをセット\r\n            let cameraSelector = document.getElementById(\"testVideoList\") as HTMLSelectElement;\r\n\r\n            this.createCameraSelectorObject(cameraSelector);\r\n\r\n            // カメラを取得、Optionにセットしたら画面を表示\r\n            document.getElementById(\"startTestVideo\")!.classList.remove(\"hidden\");\r\n        });\r\n\r\n        document.getElementById(\"startTestVideo\")?.addEventListener(\"click\", async () => {\r\n            const nowCamera = document.getElementById(\"testVideoList\") as HTMLSelectElement;\r\n            const startVideoMedia = new StartVideoMedia();\r\n            videoElement = await startVideoMedia.setVideo(\r\n                nowCamera.value,\r\n                \"testVideo\",\r\n                200,\r\n                150\r\n            );\r\n        });\r\n\r\n        document.getElementById(\"endVideoTest\")?.addEventListener(\"click\", async () => {\r\n            videoElement.pause();\r\n            videoElement.load();\r\n            const source = videoElement.querySelector(\"source\");\r\n            if (source != null) {\r\n                source.src = \"\";\r\n                videoElement.load();\r\n            }\r\n        })\r\n    }\r\n    \r\n    private setDevices = async () => {\r\n        const devices = (await navigator.mediaDevices.enumerateDevices());\r\n        this.cameraContainer = [];\r\n        devices.forEach(device => {\r\n            if (device.kind !== \"videoinput\") {\r\n                return;\r\n            }\r\n            this.cameraContainer.push(\r\n                {\r\n                    deviceId: device.deviceId,\r\n                    label: device.label\r\n                }\r\n            )\r\n        });\r\n    }\r\n\r\n    private createCameraSelectorObject = (selectObject: Element) => {\r\n        if (selectObject.childElementCount > 0) {\r\n            Array.from(selectObject.children).forEach((element: Element) => {\r\n                element.remove();\r\n            });\r\n        }\r\n        this.cameraContainer.forEach((camera) => {\r\n            const cameraOptionElement = document.createElement(\"option\");\r\n            cameraOptionElement.value = camera.deviceId;\r\n            cameraOptionElement.text = camera.label;\r\n            selectObject.appendChild(cameraOptionElement);\r\n        });\r\n    }\r\n}","import { SignalR } from \"@root/share/SignalR\";\r\nimport { RegisterEndHand } from \"./RegisterEndHand\";\r\nimport { SetEventListner } from \"@root/share/SetEventListner\";\r\n\r\nexport class EndHand {\r\n    setEndHandRegisterEvent = (signalR: SignalR) => {\r\n        SetEventListner.setEvent(\r\n            document.getElementById(\"endHandModalWindow\") as HTMLElement,\r\n            \"click\",\r\n            \"#correctModal\",\r\n            () => {\r\n                const registerEndHand = new RegisterEndHand();\r\n                registerEndHand.register();\r\n            }\r\n        )\r\n\r\n        signalR.get(\"SendEndHandJson\", (endHandJson) => {\r\n            endHandJson  = <{ [key: string]: string }>endHandJson;\r\n            const resultModal = document.getElementById(\"resultModalWindow\") as HTMLElement;\r\n            resultModal.innerHTML = endHandJson[\"result\"] as string;\r\n\r\n            document.getElementById(\"resultModalWrapper\")?.classList.remove(\"hidden\");\r\n\r\n            document.getElementById(\"nextHand\")?.addEventListener(\"click\", () => {\r\n                document.getElementById(\"nowHand\")?.classList.remove(\"hidden\");\r\n                document.getElementById(\"nextResult\")?.classList.remove(\"hidden\");\r\n                document.getElementById(\"nowResult\")?.classList.add(\"hidden\");\r\n            });\r\n\r\n            document.getElementById(\"nowHand\")?.addEventListener(\"click\", () => {\r\n                document.getElementById(\"nowHand\")?.classList.add(\"hidden\");\r\n                document.getElementById(\"nextResult\")?.classList.add(\"hidden\");\r\n                document.getElementById(\"nowResult\")?.classList.remove(\"hidden\");\r\n            });\r\n\r\n            document.getElementById(\"resultConfirm\")?.addEventListener(\"click\", () => {\r\n                if (document.getElementById(\"mainContents\") != null) {\r\n                    document.getElementById(\"mainContents\")!.innerHTML = endHandJson[\"gameData\"] as string;\r\n                }\r\n\r\n                document.getElementById(\"resultModalWrapper\")?.classList.add(\"hidden\");\r\n                document.getElementById(\"endHandModalWrapper\")?.classList.add(\"hidden\");\r\n                if (document.getElementById(\"listStartGameButton\") != null) {\r\n                    // ボタンイベントをキック\r\n                    document.getElementById(\"listStartGameButton\")!.click();\r\n                }\r\n            });\r\n        });\r\n    }\r\n}","import { FetchApi } from \"@root/share/FetchApi\";\r\n\r\nexport class RecordMedia {\r\n    url: string;\r\n    method: string;\r\n    headers: { [key: string]: string };\r\n    responseKind: string;\r\n    isStopRecording: boolean = false;\r\n    recordingInterval: number = 0;\r\n    recordBlobs: RecordBlob[] = [];\r\n\r\n    constructor(\r\n        url: string\r\n    ) {\r\n        this.url = url;\r\n        this.method = 'POST';\r\n        this.headers = {\r\n            \"Content-Type\": \"application/json\",\r\n            'X-Requested-With': 'XMLHttpRequest'\r\n        };\r\n        this.responseKind = \"json\";\r\n    } \r\n\r\n    startRecording = (\r\n        eventNumber: string,\r\n        gameNumber: string,\r\n        handNumber: string,\r\n        handSubNumber: string,\r\n        mediaMinutes: string,\r\n        ...mediaAssociates: {[key: string]: (MediaStream | string | boolean | null)}[]\r\n    ) => {\r\n        this.recordBlobs = mediaAssociates\r\n            .map(mediaAssociate => new RecordBlob(\r\n                eventNumber,\r\n                gameNumber,\r\n                handNumber,\r\n                handSubNumber,\r\n                mediaMinutes,\r\n                <string>mediaAssociate.MediaNumber,\r\n                <MediaStream>mediaAssociate.MediaStream,\r\n                <boolean>mediaAssociate.IsVideo\r\n            ));\r\n\r\n        this.recordBlobs.forEach(recordBlob => {\r\n            recordBlob.recorder(this.encodeBlob);\r\n        });\r\n\r\n        this.recordingInterval = window.setInterval(\r\n            () => {\r\n                this.recordBlobs.forEach(recordBlob => {\r\n                    recordBlob.mediaRecorder?.stop();\r\n                    recordBlob.mediaRecorder?.start();\r\n                    this.encodeBlob(recordBlob);\r\n                });\r\n            },\r\n            1000 * Number(mediaMinutes)\r\n        );\r\n    }\r\n\r\n    stopRecording = () => {\r\n        clearInterval(this.recordingInterval);\r\n        this.recordBlobs.forEach(recordBlob => {\r\n            recordBlob.isStopRecording = true;\r\n            recordBlob.mediaRecorder?.stop();\r\n        });\r\n        return this.recordBlobs.length;\r\n    }\r\n\r\n    private encodeBlob = ( recordBlob: RecordBlob ) => {\r\n        let recordedMediaProperty = recordBlob.recordedMediaProperty;\r\n        // fixme メソッド呼び出しにして直接書き換えないようにする\r\n        if (recordBlob.blob?.length ?? 0 > 0) {\r\n            const inBlob = new Blob(recordBlob.blob, { type: recordBlob.blob[0].type });\r\n            // 保存した時点で、Blobの中身を消去\r\n            recordBlob.blob = [];\r\n\r\n            const fr = new FileReader();\r\n            fr.readAsDataURL(inBlob);\r\n            fr.onload = () => {\r\n                const result = fr.result as string;\r\n                if (!result) {\r\n                    throw new Error();\r\n                }\r\n                const base64 = result.slice(result.indexOf(',') + 1);\r\n\r\n                recordedMediaProperty.MediaCount = recordBlob.mediaCount.toString();\r\n                recordedMediaProperty.Base64 = base64;\r\n                recordBlob.mediaCount++;\r\n\r\n                this.sendBlob(recordedMediaProperty).then(() => {\r\n                    console.log(\"arrival\");\r\n                }).catch(e => {\r\n                    // fixme 最終的にはエラーログを吐く\r\n                    console.log(e);\r\n                    throw e;\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    private sendBlob = async (recordedVideoProperty: { [key: string]: string | boolean | null }) => {\r\n        const fetchApi = new FetchApi();\r\n\r\n        return await fetchApi.send(\r\n            this.url,\r\n            this.method,\r\n            this.headers,\r\n            recordedVideoProperty,\r\n            this.responseKind\r\n        ).then(async (data: boolean) => {\r\n            if (data) {\r\n            }\r\n        }).catch(e => {\r\n            throw e;\r\n        });\r\n    }\r\n}\r\n\r\nclass RecordBlob {\r\n    isStopRecording: boolean = false;\r\n    recordedMediaProperty: { [key: string]: string | boolean | null };\r\n    mediaCount: number = 0;\r\n    isVideo: boolean = false;\r\n    mediaRecorder?: MediaRecorder;\r\n    mediaStream: MediaStream;\r\n    recordingInterval?: number;\r\n    blob: Blob[] = [];\r\n\r\n    constructor(\r\n\r\n        eventNumber: string,\r\n        gameNumber: string,\r\n        handNumber: string,\r\n        handSubNumber: string,\r\n        mediaMinutes: string,\r\n        mediaNumber: string | null,\r\n        mediaStream: MediaStream,\r\n        isVideo: boolean\r\n    ) {\r\n        this.recordedMediaProperty = {\r\n            EventNumber: eventNumber,\r\n            GameNumber: gameNumber,\r\n            HandNumber: handNumber,\r\n            HandSubNumber: handSubNumber,\r\n            MediaNumber: mediaNumber,\r\n            MediaCount: \"\",\r\n            MediaMinutes: mediaMinutes.toString(),\r\n            Base64: \"\",\r\n            IsVideo: isVideo,\r\n            IsEndFile: false\r\n        };\r\n        this.isVideo = isVideo;\r\n        this.mediaStream = mediaStream;\r\n    }\r\n\r\n    recorder = (encodeBlob: (recordBlob: RecordBlob) => void) => {\r\n        const mediaType = this.isVideo ? \"video\" : \"audio\";\r\n        const mime = MediaRecorder.isTypeSupported(`${mediaType}/webm; codecs=vp9`) ?\r\n            `${mediaType}/webm; codecs=vp9` :\r\n            `${mediaType}/webm`;\r\n\r\n        this.mediaRecorder = new MediaRecorder(this.mediaStream, { mimeType: mime });\r\n        this.blob = [];\r\n\r\n        // 記録開始\r\n        this.mediaRecorder.ondataavailable = (e: BlobEvent) => {\r\n            (this.blob).push(e.data);\r\n            if (this.isStopRecording) {\r\n                this.recordedMediaProperty.IsChangeFile = true;\r\n                encodeBlob(this);\r\n            }\r\n        }\r\n\r\n        this.mediaRecorder.start();\r\n    }\r\n}","import { SignalR } from \"@root/share/SignalR\";\r\nimport { SetEventListner } from \"@root/share/SetEventListner\"\r\nimport { RecordMedia } from \"@root/GameData/RecordMedia\"\r\n\r\nexport class RecordVideo {\r\n    setRecordEvent = (signalR: SignalR) => {\r\n        SetEventListner.setEvent(\r\n            document.getElementById(\"listModalWindow\"),\r\n            \"click\",\r\n            \"#startRecordingButton\",\r\n            async (event) => {\r\n                this.activateVideo(signalR, event);\r\n            },\r\n            true\r\n        )\r\n    }\r\n\r\n    private activateVideo = async (signalR: SignalR, event: Event) => {\r\n        const medias = document.getElementsByClassName(\"canvasVideo\") as HTMLCollectionOf<HTMLCanvasElement>;\r\n        const videoMinutes = 10;\r\n\r\n        const recordMedia = new RecordMedia('/GameData/RecordedVideo');\r\n\r\n        const mediaAssociates = Array.from(medias)\r\n            .map((media: HTMLCanvasElement) => {\r\n                if (media.dataset.cvenable != \"0\") {\r\n                    return {\r\n                        MediaStream: media.captureStream(),\r\n                        MediaNumber: (<HTMLElement>media.closest(\".videoWrapper\")).dataset.videonumber as string,\r\n                        IsVideo: true\r\n                    }\r\n                }\r\n            }).filter(Boolean) as {[key: string]: (string | MediaStream | boolean)}[];\r\n\r\n        recordMedia.startRecording(\r\n            (<HTMLInputElement>document.getElementById(\"eventNumber\")).value,\r\n            (<HTMLInputElement>document.getElementById(\"gameNumber\")).value,\r\n            (<HTMLInputElement>document.getElementById(\"handNumber\")).value,\r\n            (<HTMLInputElement>document.getElementById(\"handSubNumber\")).value,\r\n            videoMinutes.toString(),\r\n            ...mediaAssociates\r\n        );\r\n\r\n        // 録画停止用イベント生成\r\n        (<HTMLButtonElement>event.target).textContent = \"録画停止\";\r\n        SetEventListner.setEvent(\r\n            document.getElementById(\"listModalWindow\"),\r\n            \"click\",\r\n            \"#startRecordingButton\",\r\n            async () => {\r\n                (<HTMLButtonElement>event.target).disabled = true;\r\n                const mediaCount = recordMedia.stopRecording();\r\n                let returnedCount = 0;\r\n                signalR.get(\"SendMoveFileFinished\", () => {\r\n                    // 通知が来たら完了カウントを進める\r\n                    returnedCount++;\r\n\r\n                    // 全コピーが終わったら終了処理を走らせる\r\n                    if (mediaCount === returnedCount) {\r\n                        this.getRecordingFinished(signalR);\r\n                    }\r\n                });\r\n            },\r\n            true\r\n        );\r\n    }\r\n\r\n    private getRecordingFinished = (signalR: SignalR) => {\r\n        const recordingCommentaryElement = document.getElementById(\"startRecordingButton\") as HTMLButtonElement;\r\n        signalR.get(\"SendRecordingFinished\", () => {\r\n            recordingCommentaryElement.textContent = \"記録開始\";\r\n            recordingCommentaryElement.disabled = false;\r\n\r\n            SetEventListner.setEvent(\r\n                document.getElementById(\"listModalWindow\"),\r\n                \"click\",\r\n                \"#startRecordingButton\",\r\n                async (event) => {\r\n                    return this.activateVideo(signalR, event);\r\n                },\r\n                true\r\n            );\r\n        });\r\n\r\n        // 終了処理送信\r\n        signalR.send(\r\n            \"FinishRecording\",\r\n            (<HTMLInputElement>document.getElementById(\"eventNumber\")).value,\r\n            (<HTMLInputElement>document.getElementById(\"gameNumber\")).value,\r\n            \"management/\"\r\n        );\r\n    }\r\n}","import { FetchApi } from \"@root/share/FetchApi\";\r\nimport { SetEventListner } from \"@root/share/SetEventListner\";\r\n\r\nexport class RegisterEndGame {\r\n    url: string;\r\n    method: string;\r\n    headers: { [key: string]: string };\r\n    responseKind: string;\r\n    endGameProperty: {\r\n        [key: string]: string | null\r\n    } = {\r\n        EventNumber: null,\r\n        GameNumber: null\r\n        };\r\n\r\n    setGameEndEvent = () => {\r\n        SetEventListner.setEvent(\r\n            document.getElementById(\"listModalWindow\") as HTMLElement,\r\n            \"click\",\r\n            \"#endGamebutton\",\r\n            () => {\r\n                this.setGameEnd().then(() => {\r\n                    // 実際はリザルトの表示を入れたほうが良さそう\r\n                    window.location.reload();\r\n                });\r\n            }\r\n        )\r\n    }\r\n\r\n    constructor() {\r\n        this.url = '/Event/EndGame';\r\n        this.method = 'POST';\r\n        this.headers = {\r\n            \"Content-Type\": \"application/json\",\r\n            'X-Requested-With': 'XMLHttpRequest'\r\n        };\r\n        this.responseKind = \"json\";\r\n\r\n        this.endGameProperty.EventNumber\r\n            = (<HTMLInputElement>document.getElementById(\"eventNumber\")).value;\r\n\r\n        this.endGameProperty.GameNumber\r\n            = (<HTMLInputElement>document.getElementById(\"gameNumber\")).value;\r\n    }\r\n\r\n    private setGameEnd = async (): Promise<void> => {\r\n        const fetchApi = new FetchApi();\r\n\r\n        return await fetchApi.send(\r\n            this.url,\r\n            this.method,\r\n            this.headers,\r\n            this.endGameProperty,\r\n            this.responseKind\r\n        ).then(async (data: boolean) => {\r\n            if (data) {\r\n                window.location.reload();\r\n            }\r\n        }).catch(e => {\r\n            throw e;\r\n        });\r\n    }\r\n}","import { FetchApi } from \"@root/share/FetchApi\";\r\n\r\nexport class RegisterEndHand {\r\n    url: string;\r\n    method: string;\r\n    headers: { [key: string]: string };\r\n    responseKind: string;\r\n    endHandProperty: {\r\n        [key: string]:\r\n            string |\r\n            string[] |\r\n            { [ket: string]: string } |\r\n            { [ket: string]: boolean } |\r\n            { [key: string]: string }[] |\r\n            { [key: string]: boolean }[] |\r\n            null\r\n    } = {\r\n        EventNumber: null,\r\n        HoraKind: null,\r\n        Parent: null,\r\n        RonPointDicList: null,\r\n        PickPointDic: null,\r\n        PaoPointDicList: null,\r\n        TenpaiUsersList: null,\r\n        LeachUsersList: null,\r\n        MyaoUsersList: null,\r\n        VideoIdDic: null,\r\n        VideoNameDic: null,\r\n        ValidVideoDic: null\r\n    };\r\n    \r\n    constructor() {\r\n        this.url = '/GameData/EndHandRegister';\r\n        this.method = 'POST';\r\n        this.headers = {\r\n            \"Content-Type\": \"application/json\",\r\n            'X-Requested-With': 'XMLHttpRequest'\r\n        };\r\n        this.responseKind = \"json\";\r\n\r\n        this.endHandProperty.EventNumber\r\n            = (<HTMLInputElement>document.getElementById(\"eventNumber\")).value;\r\n    }\r\n\r\n    register = async (): Promise<{ [key: string]: string }> => {\r\n        const horaKind = (<HTMLInputElement>document.getElementById(\"horaKind\")).value;\r\n\r\n        this.endHandProperty.HoraKind = horaKind;\r\n        this.endHandProperty.Parent = (<HTMLSelectElement>document.getElementById(\"parent\")).value;\r\n\r\n        const toUserElementList = document.getElementsByClassName(\"toUser\");\r\n        if (horaKind == \"1\") {\r\n            // ツモ点数\r\n            const pickPointElementList = document.getElementsByClassName(\"pickPoint\");\r\n            if (pickPointElementList.length) {\r\n                let pickPoinDic: { [key: string]: string } = { UserCd: (<HTMLInputElement>toUserElementList[0]).value };\r\n                let pointList: string[] = []\r\n                Array.from(pickPointElementList).forEach((pickPointElement, index) => {\r\n                    pointList.push((<HTMLInputElement>pickPointElement).value);\r\n                });\r\n                if (pointList.length > 1) {\r\n                    if (parseInt(pointList[0]) > parseInt(pointList[1])) {\r\n                        pickPoinDic[\"TumoPoint\"] = pointList[1];\r\n                        pickPoinDic[\"ParentTumoPoint\"] = pointList[0];\r\n                    } else {\r\n                        pickPoinDic[\"TumoPoint\"] = pointList[0];\r\n                        pickPoinDic[\"ParentTumoPoint\"] = pointList[1];\r\n                    }\r\n                } else {\r\n                    pickPoinDic[\"TumoPoint\"] = pointList[0];\r\n                }\r\n                this.endHandProperty.PickPointDic = pickPoinDic;\r\n            }\r\n        }\r\n\r\n        if (horaKind == \"2\") {\r\n            // ロン点数\r\n            const fromUser = (document.getElementById(\"fromUser\") as HTMLInputElement)?.value ?? null;\r\n            if (toUserElementList.length) {\r\n                let ronDicList: { [key: string]: string }[] = [];\r\n                Array.from(toUserElementList).forEach(toUserElement => {\r\n                    const pointElement = toUserElement.nextElementSibling;\r\n                    ronDicList.push(\r\n                        {\r\n                            UserCd: (<HTMLSelectElement>toUserElement).value,\r\n                            Point: (<HTMLInputElement>pointElement).value,\r\n                            DealInUserCd: fromUser\r\n                        }\r\n                    )\r\n                });\r\n                this.endHandProperty.RonPointDicList = ronDicList;\r\n            }\r\n        }\r\n\r\n        // paoのチェック確認\r\n        const paoElement = document.getElementById(\"pao\") as HTMLInputElement;\r\n        if (paoElement.checked) {\r\n            // 包点数　包だけは基本支払い者基準になってる　二重Listを作る\r\n            // Listは[もらった人、あげた人、点数]\r\n            const paoUserElementList = document.getElementsByClassName(\"paoUser\");\r\n            if (paoUserElementList.length) {\r\n                let paoPointDicList: { [key: string]: string }[] = [];\r\n                if (parseInt(horaKind) < 20) {\r\n                    // ダブロン、トリロンでなければToUserもpaoUserも一人　ロンとツモの区別は不要\r\n                    const toUser = (<HTMLSelectElement>document.getElementsByClassName(\"toUser\")[0]).value;\r\n                    const paoUser = (<HTMLSelectElement>paoUserElementList[0]).value;\r\n                    const paoPoint = (<HTMLSelectElement>document.getElementsByClassName(\"paoPoint\")[0]).value;\r\n                    paoPointDicList = [\r\n                        {\r\n                            UserCd: toUser,\r\n                            PaoUserCd: paoUser,\r\n                            PaoPoint: paoPoint\r\n                        }\r\n                    ];\r\n                } else {\r\n                    Array.from(paoUserElementList).forEach((paoUserElement, index) => {\r\n                        if (\r\n                            index > 0 &&\r\n                            (<HTMLInputElement>paoUserElement.previousElementSibling).checked\r\n                        ) {\r\n                            return;\r\n                        }\r\n                        const paoUserToElement = paoUserElement\r\n                            .nextElementSibling!\r\n                            .nextElementSibling!;\r\n                        const paoPointElement = paoUserToElement.nextElementSibling!;\r\n                        paoPointDicList[index] = {\r\n                            UserCd: (<HTMLInputElement>paoUserToElement).value,\r\n                            PaoUserCd: (<HTMLInputElement>paoUserElement).value,\r\n                            PaoPoint: (<HTMLInputElement>paoPointElement).value\r\n                        }\r\n                    });\r\n                }\r\n                this.endHandProperty.PaoPointDicList = paoPointDicList;\r\n            }\r\n        }\r\n\r\n        // 立直\r\n        const leachUsersElement = document.getElementsByClassName(\"leach\");\r\n        if (leachUsersElement.length) {\r\n            let leachUsersArray: string[] = [];\r\n            Array.from(leachUsersElement).forEach(element => {\r\n                if ((<HTMLInputElement>element).checked) {\r\n                    const leachCameraNumber = (<HTMLInputElement>element).value;\r\n                    const userCdElement = (<HTMLInputElement>document.getElementById(\"userCd\" + leachCameraNumber));\r\n                    leachUsersArray.push(userCdElement.value);\r\n                }\r\n            });\r\n            if (leachUsersArray.length > 0) {\r\n                this.endHandProperty.LeachUsersList = leachUsersArray;\r\n            }\r\n        }\r\n\r\n        // 副露\r\n        const myaoUsersElement = document.getElementsByClassName(\"myao\");\r\n        if (myaoUsersElement.length) {\r\n            let myaoUsersArray: string[] = [];\r\n            Array.from(myaoUsersElement).forEach(element => {\r\n                if ((<HTMLInputElement>element).checked) {\r\n                    const myaoCameraNumber = (<HTMLInputElement>element).value;\r\n                    const userCdElement = (<HTMLInputElement>document.getElementById(\"userCd\" + myaoCameraNumber));\r\n                    myaoUsersArray.push(userCdElement.value);\r\n                }\r\n            });\r\n            if (myaoUsersArray.length > 0) {\r\n                this.endHandProperty.MyaoUsersList = myaoUsersArray;\r\n            }\r\n        }\r\n\r\n        // ビデオID\r\n        const videoSelectElement = document.getElementsByClassName(\"cameraSelector\");\r\n        if (videoSelectElement.length) {\r\n            let videoIdDic: { [key: string]: string } = {};\r\n            let videoNameDic: { [key: string]: string } = {};\r\n            let validVideoDic: { [key: string]: boolean } = {};\r\n            Array.from(videoSelectElement).forEach((element, index) => {\r\n                if (index >= 4) {\r\n                    return;\r\n                }\r\n                const userCdElement = element\r\n                    .closest(\".videoController\")!\r\n                    .querySelector(\".userList\")! as HTMLSelectElement;\r\n                const selectedIndex = (<HTMLSelectElement>element).selectedIndex;\r\n                const videoCheckerElement = element\r\n                    .closest(\".videoController\")!\r\n                    .querySelector(\".videoChecker\")! as HTMLInputElement;\r\n                videoIdDic[userCdElement.value] = (<HTMLSelectElement>element).value;\r\n                videoNameDic[userCdElement.value] = (<HTMLSelectElement>element).options[selectedIndex].text;\r\n                validVideoDic[userCdElement.value] = videoCheckerElement.checked;\r\n            });\r\n            this.endHandProperty.VideoIdDic = videoIdDic;\r\n            this.endHandProperty.VideoNameDic = videoNameDic;\r\n            this.endHandProperty.ValidVideoDic = validVideoDic;\r\n        }\r\n\r\n        // 通常流局\r\n        if (horaKind == \"30\") {\r\n            const tenpaiElement = document.getElementsByClassName(\"tenpai\");\r\n            let tenpaiUsersArray: string[] = [];\r\n            Array.from(tenpaiElement).forEach(element => {\r\n                if ((<HTMLInputElement>element).checked) {\r\n                    tenpaiUsersArray.push((<HTMLInputElement>element).value);\r\n                }\r\n            });\r\n            this.endHandProperty.TenpaiUsersList = tenpaiUsersArray;\r\n        }\r\n\r\n        console.log(this.endHandProperty);\r\n\r\n        const fetchApi = new FetchApi();\r\n\r\n        return await fetchApi.send(\r\n            this.url,\r\n            this.method,\r\n            this.headers,\r\n            this.endHandProperty,\r\n            this.responseKind,\r\n            false\r\n        ).catch(e => {\r\n            throw e;\r\n        });\r\n    }\r\n}","import { FetchApi } from \"@root/share/FetchApi\";\r\n\r\nexport class SelectEndHand {\r\n    url: string;\r\n    method: string;\r\n    headers: { [key: string]: string };\r\n    responseKind: string;\r\n    eventNumber: string;\r\n\r\n    constructor() {\r\n        this.url = '/GameData/EndHandChangeDisplay';\r\n        this.method = 'POST';\r\n        this.headers = {\r\n            \"Content-Type\": \"application/json\",\r\n            'X-Requested-With': 'XMLHttpRequest'\r\n        };\r\n        this.responseKind = \"text\";\r\n\r\n        this.eventNumber = (<HTMLInputElement>document.getElementById(\"eventNumber\")).value;\r\n    }\r\n\r\n    setHoraKindEvent = () => {\r\n        document.getElementById(\"horaKind\")?.addEventListener(\r\n            \"change\",\r\n            () => {\r\n                this.sendEndHand();\r\n            }\r\n        );\r\n    }\r\n\r\n    private sendEndHand = async () => {\r\n        const horaKind = $(\"#horaKind\").val()?.toString() ?? \"\";\r\n        this.rewritePartial({\r\n            EventNumber: this.eventNumber,\r\n            HoraKind: horaKind\r\n        });\r\n    }\r\n\r\n    private changeToUserEventListner = (horaKind: string) => {\r\n        const toUserElementList = document.getElementsByClassName(\"toUser\");\r\n        toUserElementList[0].addEventListener(\"change\", () => {\r\n            this.changeToUserEvent(horaKind, <HTMLSelectElement>toUserElementList[0])\r\n        });\r\n    }\r\n\r\n    private changeToUserEvent = (horaKind: string, toUserElement: HTMLSelectElement) => {\r\n        const toUser = toUserElement.value.toString() ?? \"\";\r\n        const index = toUserElement.selectedIndex;\r\n        const parent = $(\"#parent\").val()?.toString() ?? \"\";\r\n        const isPao = (document.getElementById(\"pao\") as HTMLInputElement).checked;\r\n        return this.rewritePartial(\r\n            {\r\n                EventNumber: this.eventNumber,\r\n                HoraKind: horaKind,\r\n                Parent: parent,\r\n                ToUser: toUser,\r\n                IsPao: isPao\r\n            }\r\n        ).then(() => {\r\n            console.log(\"leach\");\r\n            const newToUserElement = document.getElementsByClassName(\"toUser\")[0] as HTMLSelectElement;\r\n            newToUserElement.options[index].selected = true;\r\n            if (parent == toUser) {\r\n\r\n            }\r\n        });\r\n    }\r\n\r\n    private rewritePartial = async (\r\n        body: { [key: string]: string | boolean }\r\n    ) => {\r\n        let fetchApi = new FetchApi();\r\n        return await fetchApi.send(\r\n            this.url,\r\n            this.method,\r\n            this.headers,\r\n            body,\r\n            this.responseKind\r\n        ).then((data: string) => {\r\n            $(\"#endGame\").empty();\r\n            $(\"#endGame\").append(data);\r\n            const horaKind = $(\"#horaKind\").val()?.toString() ?? \"\";\r\n            if (horaKind == \"1\") {\r\n                this.changeToUserEventListner(horaKind);\r\n            }\r\n            return \"\";\r\n        }).catch(e => {\r\n            console.log(e);\r\n            //fixme エラー処理\r\n        });\r\n    }\r\n}","import { SetOutSameClassSelect } from \"@root/share/SetOutSameClassSelect\"\r\nimport { SetEventListner } from \"@root/share/SetEventListner\"\r\n\r\nexport class ModifiedUserSelect {\r\n    static setAvoidDuplication = () => {\r\n        const setOutSameClassSelect = new SetOutSameClassSelect();\r\n        const userClass = document.getElementsByClassName(\"userList\") as HTMLCollectionOf<HTMLSelectElement>;\r\n        const directionClass = document.getElementsByClassName(\"directionList\") as HTMLCollectionOf<HTMLSelectElement>;\r\n        setOutSameClassSelect.setSelectorEvent(userClass);\r\n        setOutSameClassSelect.setSelectorEvent(directionClass);\r\n    }\r\n\r\n    static hangingVideoSetter = (parentElementName: string) => {\r\n        const userClass = document.getElementsByClassName(\"userList\") as HTMLCollectionOf<HTMLSelectElement>;\r\n        Array.from(userClass).forEach((userElement, index) => {\r\n            const parentElement = userElement.closest(parentElementName) as HTMLElement;\r\n            SetEventListner.setEvent(\r\n                parentElement,\r\n                \"change\",\r\n                \"#userCd\"+index,\r\n                (event) => {\r\n                    const targetDirection = (<HTMLSelectElement>event.target)\r\n                        .closest(\".videoController\")!\r\n                        .querySelector(\".directionList\");\r\n                    if ((<HTMLSelectElement>event.target).value == \"99\") {\r\n                        (<HTMLSelectElement>targetDirection).value = \"99\";\r\n                        (<HTMLSelectElement>targetDirection).disabled = true;\r\n                        // changeイベントを発火させる\r\n                        (<HTMLSelectElement>targetDirection).dispatchEvent(new Event(\"change\"));\r\n                    } else {\r\n                        (<HTMLSelectElement>targetDirection).disabled = false;\r\n                    }\r\n                }\r\n            )\r\n        });\r\n    }\r\n}","import { FetchApi } from \"@root/share/FetchApi\";\r\nimport { SetEventListner } from \"@root/share/SetEventListner\";\r\n\r\nexport class ShowPoint {\r\n    url: string;\r\n    method: string;\r\n    headers: { [key: string]: string };\r\n    responseKind: string;\r\n    showPointProperty: {\r\n        [key: string]: string |\r\n        string[] |\r\n        { [key: string]: string } |\r\n        null\r\n    } = {\r\n        EventNumber: null,\r\n        GameNumber: null\r\n    };\r\n\r\n    constructor() {\r\n        this.url = '/GameData/ShowPoint';\r\n        this.method = 'POST';\r\n        this.headers = {\r\n            \"Content-Type\": \"application/json\",\r\n            'X-Requested-With': 'XMLHttpRequest'\r\n        };\r\n        this.responseKind = \"text\";\r\n\r\n        this.showPointProperty.EventNumber\r\n            = (<HTMLInputElement>document.getElementById(\"eventNumber\")).value;\r\n\r\n        this.showPointProperty.GameNumber\r\n            = (<HTMLInputElement>document.getElementById(\"gameNumber\")).value;\r\n    }\r\n\r\n    setStartEvent = () => {\r\n        SetEventListner.setEvent(\r\n            document.getElementById(\"listModalWindow\"),\r\n            \"click\",\r\n            \"#showPointButton\",\r\n            () => {\r\n                this.show().then((data: string) => {\r\n                    document.getElementById(\"showPointModalWindow\")!.innerHTML = data;\r\n                    document.getElementById(\"showPointModalWrapper\")!.classList.remove(\"hidden\");\r\n                });\r\n            }\r\n        );\r\n    }\r\n\r\n    private show = async (): Promise<string> => {\r\n        const fetchApi = new FetchApi();\r\n\r\n        return await fetchApi.send(\r\n            this.url,\r\n            this.method,\r\n            this.headers,\r\n            this.showPointProperty,\r\n            this.responseKind\r\n        ).then(async (data: string) => {\r\n            return data;\r\n        }).catch(e => {\r\n            throw e;\r\n        });\r\n    }\r\n}","import { SetEventListner } from \"./SetEventListner\"\r\n\r\nexport class ControlModal {\r\n    private modalKind: string;\r\n    private openModalElementSelector: string;\r\n\r\n    constructor(openModalElementSelector: string, modalKind: string = \"\") {\r\n        this.modalKind = modalKind;\r\n        this.openModalElementSelector = openModalElementSelector;\r\n    }\r\n\r\n    setControl = () => {\r\n        Array.from(document.getElementsByClassName(\"modalWindow\")).forEach((element) => {\r\n            const parentElement = element as HTMLElement;\r\n\r\n            SetEventListner.setEvent(\r\n                parentElement,\r\n                \"click\",\r\n                \".closeModal\",\r\n                () => {\r\n                    this.hidden();\r\n                }\r\n            )\r\n\r\n            // 外をクリックしたときのクローズイベント\r\n            SetEventListner.setEvent(\r\n                parentElement,\r\n                \"click\",\r\n                \"#\" + this.modalKind + \"ModalWrapper\",\r\n                (event: Event) => {\r\n                    (<HTMLButtonElement>event.target)\r\n                        .closest(\"#\" + this.modalKind + \"ModalWindow\") ?? this.hidden();\r\n                }\r\n            );\r\n\r\n            SetEventListner.setEvent(\r\n                parentElement,\r\n                \"click\",\r\n                this.openModalElementSelector,\r\n                (event: Event) => {\r\n                    this.show();\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    private show = () => {\r\n        document.getElementById(this.modalKind + \"ModalWrapper\")!.classList.remove(\"hidden\");\r\n    }\r\n\r\n    private hidden = () => {\r\n        console.log(this.modalKind);\r\n        console.log(document.getElementById(this.modalKind + \"ModalWrapper\"));\r\n        document.getElementById(this.modalKind + \"ModalWrapper\")!.classList.add(\"hidden\");\r\n    }\r\n}","export class FetchApi {\r\n    send = async (\r\n        url: string,\r\n        method: string,\r\n        headers: { [key: string]: string },\r\n        body: {\r\n            [key: string]:\r\n            string |\r\n            string[] |\r\n            string[][] |\r\n            { [key: string]: string } |\r\n            { [ket: string]: boolean } |\r\n            { [key: string]: string }[] |\r\n            { [key: string]: boolean }[] |\r\n            Uint8Array |\r\n            number[] |\r\n            boolean |\r\n            FormDataEntryValue |\r\n            null\r\n        } | string | null,\r\n        //body: any,\r\n        responseKind: string = \"json\",\r\n        needResponseData: boolean = true\r\n    ) => {\r\n        let request;\r\n\r\n        if (method == \"GET\") {\r\n            request = new Request(url, {\r\n                method: method,\r\n                headers: headers\r\n            });\r\n        } else {\r\n            request = new Request(url, {\r\n                method: method,\r\n                headers: headers,\r\n                body: JSON.stringify(body)\r\n            });\r\n        }\r\n\r\n        const response = await fetch(request).catch(e => { throw e });\r\n\r\n        if (!response.ok) {\r\n            throw new Error(response.statusText);\r\n        }\r\n\r\n        if (!needResponseData) {\r\n            return;\r\n        }\r\n\r\n        switch (responseKind) {\r\n            case \"json\":\r\n                return await this.fetchResonse(response.json()).catch(e => { throw e });\r\n            case \"text\":\r\n                return await this.fetchResonse(response.text()).catch(e => { throw e });\r\n        }\r\n    }\r\n\r\n    private async fetchResonse(response: Promise<any>) {\r\n        return await response.then(data => {\r\n            return data;\r\n        })\r\n        .catch(error => {\r\n            // エラー処理\r\n            console.log(error);\r\n            throw error;\r\n        });\r\n    }\r\n}\r\n","export class GetNewResolutions {\r\n    static Get = (\r\n        canvasWrapperElement: HTMLElement,\r\n        resolution: { [key: string]: number },\r\n        aspectRatioKind: string\r\n    ) => {\r\n        let dataSet: { [key: string]: { [key: string]: number } } = {};\r\n        switch (aspectRatioKind) {\r\n            case \"VGA\":\r\n                dataSet = {\r\n                    characterFrame: { x: 0, y: 400, w: 800, h: 210 },\r\n                    leftUp: { x: 0, y: 0, w: 0, h: 0 },\r\n                    field: { x: 0, y: 0, font: 0 },\r\n                    leachImage: { x: 0, y: 0, w: 0, h: 0 },\r\n                    leach: { x: 0, y: 0, font: 0 },\r\n                    honbaImage: { x: 0, y: 0, w: 0, h: 0 },\r\n                    honba: { x: 0, y: 0, font: 0 },\r\n                    face: { x: 80, y: 420, w: 150, h: 170 },\r\n                    point: { x: 780, y: 575, font: 75 },\r\n\r\n                    title: { x: 780, y: 445, font: 30 },\r\n                    name: { x: 780, y: 505, font: 60 },\r\n\r\n                    yaku: { x: 0, y: 0, font: 0 },\r\n                    kind: { x: 750, y: 385, font: 60 },\r\n                    movingPoint: { x: 780, y: 465, font: 30 },\r\n                    allow: { x: 700, y: 505, font: 45 },\r\n                }\r\n                break;\r\n            case \"HDTV\":\r\n                dataSet = {\r\n                    characterFrame: { x: 0, y: 620, w: 1280, h: 300 },\r\n                    leftUp: { x: 0, y: 0, w: 0, h: 0 },\r\n                    field: { x: 0, y: 0, font: 0 },\r\n                    leachImage: { x: 0, y: 0, w: 0, h: 0 },\r\n                    leach: { x: 0, y: 0, font: 0 },\r\n                    honbaImage: { x: 0, y: 0, w: 0, h: 0 },\r\n                    honba: { x: 0, y: 0, font: 0 },\r\n                    face: { x: 660, y: 650, w: 160, h: 180 },\r\n                    point: { x: 1245, y: 825, font: 75 },\r\n\r\n                    name: { x: 1245, y: 755, font: 60 },\r\n                    title: { x: 1245, y: 695, font: 30 },\r\n\r\n                    allow: { x: 1255, y: 755, font: 45 },\r\n                    movingPoint: { x: 1245, y: 520, font: 30 },\r\n                    yaku: { x: 0, y: 0, font: 0 },\r\n                    kind: { x: 1230, y: 755, font: 60 },\r\n                }\r\n        }\r\n\r\n        let widthRate = canvasWrapperElement.clientWidth / resolution.w;\r\n        let heightRate = canvasWrapperElement.clientHeight / resolution.h;\r\n\r\n        const canvasWidth = widthRate < heightRate ?\r\n            canvasWrapperElement.clientWidth :\r\n            canvasWrapperElement.clientHeight / resolution.h * resolution.w;\r\n        const canvasHeight = heightRate < widthRate ?\r\n            canvasWrapperElement.clientHeight :\r\n            canvasWrapperElement.clientWidth / resolution.w * resolution.h;\r\n\r\n        let fontRate = widthRate < heightRate ? widthRate : heightRate;\r\n\r\n        const canvasXFrame = Math.floor((canvasWidth - (resolution.w * widthRate)) / 2);\r\n        const canvasYFrame = Math.floor((canvasHeight - (resolution.h * heightRate)) / 2);\r\n\r\n        // widthチェック\r\n        Object.keys(dataSet).forEach((key: string) => {\r\n            dataSet[key].x = Math.floor(dataSet[key].x * widthRate) + canvasXFrame;\r\n            dataSet[key].y = Math.floor(dataSet[key].y * heightRate) + canvasYFrame;\r\n\r\n            if (\"w\" in dataSet[key]) {\r\n                dataSet[key].w = Math.floor(dataSet[key].w * widthRate);\r\n                dataSet[key].h = Math.floor(dataSet[key].h * heightRate);\r\n            } else {\r\n                dataSet[key].font = Math.floor(dataSet[key].font * fontRate);\r\n            }\r\n        });\r\n\r\n        dataSet.canvas = { w: canvasWidth, h: canvasHeight };\r\n        dataSet.video = {\r\n            x: canvasXFrame,\r\n            y: canvasYFrame,\r\n            w: Math.floor(resolution.w * widthRate),\r\n            h: Math.floor(resolution.h * heightRate)\r\n        };\r\n\r\n        return dataSet;\r\n    }\r\n}","export class SetEventListner {\r\n    static setEvent = (\r\n        parentElement: HTMLElement | undefined | null,\r\n        type: keyof HTMLElementEventMap,\r\n        targetName: string,\r\n        callback: (event: Event) => void,\r\n        atOnce: boolean = false\r\n    ) => {\r\n\r\n        const returnHandler = (event: Event) => {\r\n            const targetElement = parentElement?.querySelector(targetName);\r\n            if (event.target == targetElement) {\r\n                callback(event);\r\n                if (atOnce) {\r\n                    parentElement?.removeEventListener(type, returnHandler)\r\n                }\r\n            }\r\n        }\r\n        parentElement?.addEventListener(type, returnHandler);\r\n        return returnHandler;\r\n    }\r\n\r\n    static removeEvent = (\r\n        parentElement: HTMLElement | undefined | null,\r\n        type: keyof HTMLElementEventMap,\r\n        handler: (event: Event) => void\r\n    ) => {\r\n        parentElement?.removeEventListener(type, handler);\r\n    }\r\n}","export class SetOutSameClassSelect {\r\n\tsetSelectorEvent = (targets: HTMLCollectionOf<HTMLSelectElement>) => {\r\n\t\tthis.setSelectorEventOnce(targets);\r\n\t\tArray.from(targets).forEach((element: HTMLSelectElement) => {\r\n\t\t\t// fixme\r\n\t\t\telement.addEventListener(\"change\", (event) => {\r\n\t\t\t\tconst changedTarget = <HTMLSelectElement>event.target;\r\n\t\t\t\tthis.setSelectorEventOnce(targets, changedTarget);\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\r\n\tsetSelectorEventOnce = (\r\n\t\ttargets: HTMLCollectionOf<HTMLSelectElement>,\r\n\t\tchangedTarget: HTMLSelectElement | null = null\r\n\t) => {\r\n\t\tconst alreadySelectedValueArray: string[] = Array.from(targets).map(target => target.value);\r\n\t\tchangedTarget = changedTarget ?? targets.item(0);\r\n\r\n\t\tArray.from(targets).forEach((element: HTMLSelectElement) => {\r\n\t\t\talreadySelectedValueArray.shift();\r\n\t\t\tlet thisValue = element.value\r\n\t\t\tif (\r\n\t\t\t\telement !== changedTarget && \r\n\t\t\t\talreadySelectedValueArray.includes(element.value)\r\n\t\t\t) {\r\n\t\t\t\tthisValue = this.deduplicationOption(alreadySelectedValueArray, element);\r\n\t\t\t}\r\n\t\t\talreadySelectedValueArray.push(thisValue);\r\n\t\t});\r\n\t}\r\n\r\n\tprivate deduplicationOption = (alreadySelectedValueArray: string[], element: HTMLSelectElement) => {\r\n\t\tconst optionElements = element.children as HTMLCollectionOf<HTMLOptionElement>;\r\n\r\n\t\tfor (let optionElement of Array.from(optionElements)) {\r\n\t\t\tif (!alreadySelectedValueArray.includes(optionElement.value)) {\r\n\t\t\t\toptionElement.selected = true;\r\n\t\t\t\treturn optionElement.value;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthrow new Error(\"element anomaly\");\r\n\t}\r\n}","import * as signalR from \"@microsoft/signalr\";\r\n\r\nexport class SignalR {\r\n    private connection: signalR.HubConnection;\r\n\r\n    constructor() {\r\n        this.connection = new signalR.HubConnectionBuilder()\r\n            .withUrl(\"/hub\")\r\n            .build();\r\n    }\r\n\r\n    activate = async () => {\r\n        // 読み込み不良エラー防止のため、読み込み完了するまでBodyはHidden\r\n        document.getElementsByTagName(\"body\").item(0)!.style.visibility = \"hidden\";\r\n\r\n        await this.connectionStart();\r\n\r\n        // hiddenの解除\r\n        document.getElementsByTagName(\"body\").item(0)!.style.visibility = \"visible\";\r\n    }\r\n\r\n    private connectionStart = async () => {\r\n        await this.connection.start().catch(\r\n            // fixme error処理実装\r\n            (err) => console.log(err)\r\n        );\r\n    }\r\n\r\n    send = (sendProcessName: string, ...args: (string |number | boolean)[]) => {\r\n        this.connection.send(sendProcessName, ...args);\r\n    }\r\n\r\n    get = (getProcessName: string, callback: (json: { [key: string]: string | number | boolean } | { [key: string]: string | number }[]) => void) => {\r\n        this.connection.on(getProcessName, (\r\n            strJson: any\r\n        ) => {\r\n            let json = {};\r\n            if ((typeof json) == \"string\") {\r\n                json = JSON.parse(strJson) as { [key: string]: string | number | boolean } | { [key: string]: string | number }[];\r\n            } else {\r\n                json = strJson as { [key: string]: string | number | boolean } | { [key: string]: string | number }[];\r\n            }\r\n            callback(json);\r\n        });\r\n    }\r\n\r\n    close = () => {\r\n        this.connection.stop();\r\n    }\r\n}","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { SignalR } from \"@root/share/SignalR\";\r\nimport { SelectEndHand } from \"@root/GameData/SelectEndHand\";\r\nimport { ModifiedUserSelect } from \"@root/GameData/SetAvoidSelectDuplication\";\r\nimport { RegisterEndGame } from \"@root/GameData/RegisterEndGame\";\r\nimport { ShowPoint } from \"@root/GameData/ShowPoint\";\r\nimport { RecordVideo } from \"@root/GameData/RecordVideo\";\r\nimport { EndHand } from \"@root/GameData/EndHand\"\r\nimport { VideoControll } from \"./VideoControll\";\r\nimport { StartGame } from \"./StartGame\";\r\nimport { EventControlModal } from \"./EventControlModal\";\r\nimport { RegisterVideo } from \"./RegisterVideo\";\r\nimport { VideoTestControll } from \"./VideoTestControll\";\r\nimport { GetCamera } from \"./GetCamera\";\r\n\r\n(async () => {\r\n    const signalR = new SignalR();\r\n    const selectEndHand = new SelectEndHand();\r\n    const videoControll = new VideoControll();\r\n    const videoTestControll = new VideoTestControll();\r\n    const registerVideo = new RegisterVideo();\r\n    const startGame = new StartGame();\r\n    const endHand = new EndHand();\r\n    const registerEndGame = new RegisterEndGame();\r\n    const showPoint = new ShowPoint();\r\n    const getCamera = new GetCamera();\r\n    const recordVideo = new RecordVideo()\r\n\r\n    // 終了処理を挟み、コンストラクタプロパティを終了処理から変更できるようにする\r\n\r\n    await signalR.activate();\r\n    videoControll.controlVideoEvent(signalR);\r\n    selectEndHand.setHoraKindEvent();\r\n    startGame.setStartEvent();\r\n    endHand.setEndHandRegisterEvent(signalR);\r\n    videoTestControll.setTestVideoEvent();\r\n    registerVideo.setRegisterVideoEvent();\r\n    registerEndGame.setGameEndEvent();\r\n    showPoint.setStartEvent();\r\n    getCamera.setGetCamerEvent();\r\n    recordVideo.setRecordEvent(signalR);\r\n    EventControlModal.setModal();\r\n    ModifiedUserSelect.setAvoidDuplication();\r\n    ModifiedUserSelect.hangingVideoSetter(\"#listModalWindow\");\r\n})();"],"names":[],"sourceRoot":""}